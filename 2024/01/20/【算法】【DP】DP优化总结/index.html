

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head><!-- hexo injector head_begin start --><script src="/js/custom/auto_generate/theme_config.js" defer></script><!-- hexo injector head_begin end -->
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.jpg">
  <link rel="icon" href="/img/fluid.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#bbbbbb">
  <meta name="author" content="しずり雪">
  <meta name="keywords" content="">
  
    <meta name="description" content="DP优化   0 基本概念  1D&#x2F;1D 方程 2D&#x2F;1D 方程  1 (1D&#x2F;1D) 单调队列优化  概念 单调队列优化模板题  2 (1D&#x2F;1D) 斜率&#x2F;凸壳优化  概念 (1) \(k\) 单调不减，\(x\) 单调不减：单调队列 (2) \(k\) 无单调性，\(x\) 单调不减：二分单调栈 (3) \(k\) 单调不减，\(x\) 无单">
<meta property="og:type" content="article">
<meta property="og:title" content="【算法】【DP】DP优化总结">
<meta property="og:url" content="https://qalxry.github.io/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E3%80%90DP%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="しずり雪 の Blog">
<meta property="og:description" content="DP优化   0 基本概念  1D&#x2F;1D 方程 2D&#x2F;1D 方程  1 (1D&#x2F;1D) 单调队列优化  概念 单调队列优化模板题  2 (1D&#x2F;1D) 斜率&#x2F;凸壳优化  概念 (1) \(k\) 单调不减，\(x\) 单调不减：单调队列 (2) \(k\) 无单调性，\(x\) 单调不减：二分单调栈 (3) \(k\) 单调不减，\(x\) 无单">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://qalxry.github.io/img/piclib/ve04_b.jpg">
<meta property="article:published_time" content="2024-01-20T12:55:20.000Z">
<meta property="article:modified_time" content="2024-02-05T14:16:55.014Z">
<meta property="article:author" content="しずり雪">
<meta property="article:tag" content="Algorithm 算法">
<meta property="article:tag" content="DP">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://qalxry.github.io/img/piclib/ve04_b.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>【算法】【DP】DP优化总结 - しずり雪 の Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom/mydetails.css">
<link rel="stylesheet" href="/css/custom/fonts.css">
<link rel="stylesheet" href="/css/custom/toc.css">
<link rel="stylesheet" href="/css/custom/base.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"qalxry.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
            <script>
            document.subthemes = {
                default: "none",
                list: [{"name":"none","path":"/"},{"name":"classic","path":"/subthemes/classic/"},{"name":"modern","path":"/subthemes/modern/"}]
            };
            </script>

            <script src="/subthemes/subthemes.js" defer></script>
            <style>
                #theme-toggle-btn .nav-link {
                    display: block;
                    color: var(--navbar-text-color);
                    transition: color 0.2s ease-in-out, background-color 0.2s ease-in-out;
                }
                #theme-toggle-btn .nav-link svg {
                    transition: fill 0.2s ease-in-out;
                    fill: var(--navbar-text-color);
                }
                #theme-toggle-btn .nav-link:hover svg {
                    fill: var(--link-hover-color);
                }
            </style>
            <link rel="stylesheet" href="/subthemes/classic/css/main.css">
<link rel="stylesheet" href="/subthemes/modern/css/main.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


<body><!-- hexo injector body_begin start -->
        <script>
        console.log('[Extend Features] running...');
        document.extend_features = {"enable":false,"code_font":{"enable":false,"font_family":"SFMono-Regular,Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace","font_weight":400},"fixed_background":{"enable":false,"mask":{"enable":true,"list":[{"selector":"#web_bg","enable":true,"style":"background-color: rgba(0, 0, 0, 0.3);  border-radius: 1rem;"},{"selector":"#board","enable":true,"style":"background-color: rgba(0, 0, 0, 0);    border-radius: 1rem;"},{"selector":"#toc","enable":true,"style":"background-color: rgba(0, 0, 0, 0.15); border-radius: 1rem;"}]}}};
        </script>
        <script src="/extend_features/extend_features.js"></script>
        <!-- hexo injector body_begin end -->
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>しずり雪 の Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/diary/">
                <i class="iconfont icon-notebook"></i>
                <span>日记</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/piclib/ve04_b.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="【算法】【DP】DP优化总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-01-20 20:55" pubdate>
          2024年1月20日 晚上 20:55
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          33k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          137 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="left-sidebar side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">【算法】【DP】DP优化总结</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2024年2月5日 晚上 22:16
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="dp优化">DP优化</h1>
<!-- toc -->
<ul>
<li><a href="#0----%25E5%259F%25BA%25E6%259C%25AC%25E6%25A6%2582%25E5%25BF%25B5">0
基本概念</a>
<ul>
<li><a href="#1Dx2F1D-%25E6%2596%25B9%25E7%25A8%258B">1D/1D
方程</a></li>
<li><a href="#2Dx2F1D-%25E6%2596%25B9%25E7%25A8%258B">2D/1D
方程</a></li>
</ul></li>
<li><a href="#1-----(1Dx2F1D)-%25E5%258D%2595%25E8%25B0%2583%25E9%2598%259F%25E5%2588%2597%25E4%25BC%2598%25E5%258C%2596">1
(1D/1D) 单调队列优化</a>
<ul>
<li><a href="#%25E6%25A6%2582%25E5%25BF%25B5">概念</a></li>
<li><a href="#%25E5%258D%2595%25E8%25B0%2583%25E9%2598%259F%25E5%2588%2597%25E4%25BC%2598%25E5%258C%2596%25E6%25A8%25A1%25E6%259D%25BF%25E9%25A2%2598">单调队列优化模板题</a></li>
</ul></li>
<li><a href="#2----(1Dx2F1D)-%25E6%2596%259C%25E7%258E%2587x2F%25E5%2587%25B8%25E5%25A3%25B3%25E4%25BC%2598%25E5%258C%2596">2
(1D/1D) 斜率/凸壳优化</a>
<ul>
<li><a href="#%25E6%25A6%2582%25E5%25BF%25B5">概念</a></li>
<li><a href="#(1)-%24k%24-%25E5%258D%2595%25E8%25B0%2583%25E4%25B8%258D%25E5%2587%258F%25EF%25BC%258C%24x%24-%25E5%258D%2595%25E8%25B0%2583%25E4%25B8%258D%25E5%2587%258F%25EF%25BC%259A%25E5%258D%2595%25E8%25B0%2583%25E9%2598%259F%25E5%2588%2597">(1)
<span class="math inline">\(k\)</span> 单调不减，<span class="math inline">\(x\)</span> 单调不减：单调队列</a></li>
<li><a href="#(2)--%24k%24-%25E6%2597%25A0%25E5%258D%2595%25E8%25B0%2583%25E6%2580%25A7%25EF%25BC%258C%24x%24-%25E5%258D%2595%25E8%25B0%2583%25E4%25B8%258D%25E5%2587%258F%25EF%25BC%259A%25E4%25BA%258C%25E5%2588%2586%25E5%258D%2595%25E8%25B0%2583%25E6%25A0%2588">(2)
<span class="math inline">\(k\)</span> 无单调性，<span class="math inline">\(x\)</span> 单调不减：二分单调栈</a></li>
<li><a href="#(3)--%24k%24-%25E5%258D%2595%25E8%25B0%2583%25E4%25B8%258D%25E5%2587%258F%25EF%25BC%258C%24x%24-%25E6%2597%25A0%25E5%258D%2595%25E8%25B0%2583%25E6%2580%25A7%25EF%25BC%259A%25E5%258A%25A8%25E6%2580%2581%25E5%2587%25B8%25E5%258C%2585">(3)
<span class="math inline">\(k\)</span> 单调不减，<span class="math inline">\(x\)</span> 无单调性：动态凸包</a></li>
<li><a href="#(4)--%24k%24-%25E6%2597%25A0%25E5%258D%2595%25E8%25B0%2583%25E6%2580%25A7%25EF%25BC%258C%24x%24-%25E6%2597%25A0%25E5%258D%2595%25E8%25B0%2583%25E6%2580%25A7%25EF%25BC%259A%25E5%258A%25A8%25E6%2580%2581%25E5%2587%25B8%25E5%258C%2585">(4)
<span class="math inline">\(k\)</span> 无单调性，<span class="math inline">\(x\)</span> 无单调性：动态凸包</a></li>
</ul></li>
<li><a href="#3-----(1Dx2F1D)-%25E5%2586%25B3%25E7%25AD%2596%25E5%258D%2595%25E8%25B0%2583%25E6%2580%25A7%25E4%25BC%2598%25E5%258C%2596">3
(1D/1D) 决策单调性优化</a></li>
<li><a href="#4-----(2Dx2F1D)-WQS%25E5%25B8%25A6%25E6%259D%2583%25E4%25BA%258C%25E5%2588%2586%25E4%25BC%2598%25E5%258C%2596">4
(2D/1D) WQS带权二分优化</a>
<ul>
<li><a href="#%25E9%25A2%2598%25E7%259B%25AE%25E7%25B1%25BB%25E5%259E%258B">题目类型</a></li>
<li><a href="#%25E6%259C%25B4%25E7%25B4%25A0DP%25E6%2580%259D%25E8%25B7%25AF">朴素DP思路</a></li>
<li><a href="#WQS%25E4%25BA%258C%25E5%2588%2586%25E8%25A7%25A3%25E9%25A2%2598%25E6%2580%259D%25E8%25B7%25AF">WQS二分解题思路</a></li>
<li><a href="#WQS%25E4%25BA%258C%25E5%2588%2586%25E6%25A8%25A1%25E6%259D%25BF%25E9%25A2%2598">WQS二分模板题</a></li>
<li><a href="#WQS%25E4%25BA%258C%25E5%2588%2586%25E7%25BB%2583%25E4%25B9%25A0%25E9%25A2%2598">WQS二分练习题</a></li>
</ul></li>
<li><a href="#5-----(2Dx2F1D)-%25E5%259B%259B%25E8%25BE%25B9%25E5%25BD%25A2%25E4%25B8%258D%25E7%25AD%2589%25E5%25BC%258F%25E4%25BC%2598%25E5%258C%2596">5
(2D/1D) 四边形不等式优化</a></li>
<li><a href="#6----%25E7%259F%25A9%25E9%2598%25B5%25E4%25B9%2598%25E6%25B3%2595%25E4%25BC%2598%25E5%258C%2596">6
矩阵乘法优化</a></li>
</ul>
<!-- tocstop -->
<h2 id="基本概念">0 基本概念</h2>
<p>我们对DP的状态转移方程按照<strong>状态维度</strong>和<strong>决策点维度</strong>（转移点维度），分为
1D/1D 和 2D/1D 。</p>
<h3 id="d1d-方程">1D/1D 方程</h3>
<p>1D/1D 方程，意思是我们计算的 <span class="math inline">\(dp[i]\)</span> 的状态维度是 1 维的 <span class="math inline">\([i]\)</span> ，决策点的维度是 1 维的 <span class="math inline">\([j]\)</span> 。</p>
<p>状态转移方程：</p>
<p><span class="math display">\[
\begin{align}
f(i)&amp;=\min/\max\limits_{}\{g(j)+w(i,j)\},\quad 1\le j &lt; i
\end{align}
\]</span></p>
<p>我们按照 <span class="math inline">\(w(i,j)\)</span>
的性质继续细分：</p>
<h4 id="wij-为多项式函数">(1) <span class="math inline">\(w(i,j)\)</span> 为多项式函数</h4>
<h5 id="a.-wij-为一次函数单调队列优化">a. <span class="math inline">\(w(i,j)\)</span> 为一次函数：单调队列优化</h5>
<h5 id="b.-wij-为高次函数斜率凸壳优化">b. <span class="math inline">\(w(i,j)\)</span> 为高次函数：斜率/凸壳优化</h5>
<blockquote>
<p>其中根据 <span class="math inline">\(w(i,j)\)</span>
的情况，有不同的优化策略：</p>
<ol type="1">
<li>单调队列</li>
<li>二分队列</li>
<li>动态凸包：CDQ分治、线段树维护、李超线段树</li>
</ol>
</blockquote>
<h4 id="wij-为非多项式函数">(2) <span class="math inline">\(w(i,j)\)</span> 为非多项式函数</h4>
<h5 id="a.-wij-满足四边形不等式决策单调性优化">a. <span class="math inline">\(w(i,j)\)</span>
满足四边形不等式：决策单调性优化</h5>
<blockquote>
<p>其中根据 <span class="math inline">\(w(i,j)\)</span>
的单调性，有不同的优化策略：</p>
<ol type="1">
<li>单调队列（有单调性）</li>
<li>二分队列（无单调性）</li>
<li>CDQ分治（无单调性）</li>
</ol>
</blockquote>
<h3 id="d1d-方程-1">2D/1D 方程</h3>
<p>2D/1D 方程，意思是我们计算的 <span class="math inline">\(dp[i][j]\)</span> 的状态维度是 2 维的 <span class="math inline">\([i][j]\)</span> ，决策点的维度是 1 维的 <span class="math inline">\([k]\)</span> 。</p>
<p>状态转移方程：</p>
<p><span class="math display">\[
\begin{align}
f(i,j) &amp;= \min/\max\{g(i,k)+h(k,j)+w(i,j)\},\quad k \in [i,j-1]
\end{align}
\]</span></p>
<p>如果决策点 <span class="math inline">\([k]=[j]\)</span>
，则状态转移方程：</p>
<p><span class="math display">\[
f(i,j) = \min/\max\{g(i,j)+w(i,j)\},\quad j \in [1,i]
\]</span></p>
<p>我们继续细分：</p>
<h4 id="fij-具有凸性">(1) <span class="math inline">\(f(i,j)\)</span>
具有凸性</h4>
<p>WQS带权二分</p>
<h4 id="wij-满足四边形不等式">(2) <span class="math inline">\(w(i,j)\)</span> 满足四边形不等式</h4>
<p>四边形不等式优化（区间决策单调性）</p>
<h2 id="d1d-单调队列优化">1 (1D/1D) 单调队列优化</h2>
<h3 id="概念">概念</h3>
<p><strong>单调队列优化特征状态方程：</strong></p>
<p><span class="math display">\[
\begin{align}
dp[i]&amp;=\min/\max\{dp[j]+a[i]+b[j]\}, \quad j \in[L(i),R(i)] \\
&amp;=\min/\max\{dp[j]+b[j]\} +a[i] \\
\end{align}
\]</span></p>
<p>设 <span class="math inline">\(ds[j]= dp[j]+b[j]\)</span>，得：</p>
<p><span class="math display">\[
dp[i]=\min/\max\{ds[j]\} +a[i], \quad j \in[L(i),R(i)]
\]</span></p>
<p>由于 <span class="math inline">\(ds[j]\)</span> 仅和 <span class="math inline">\(j\)</span> 有关，与 <span class="math inline">\(i\)</span> 无关，故 <span class="math inline">\(ds[j]\)</span> 仅需计算一次即可用于全部 <span class="math inline">\(dp[i]\)</span> 的计算中。</p>
<p>未优化前，在每一轮 <span class="math inline">\(i\)</span>
的循环中都要计算一遍 <span class="math inline">\(\min/\max\{ds[j]\}，j
\in[L(i),R(i)]\)</span> ，期间有大量重复的 <span class="math inline">\(ds[j]\)</span> 计算。故考虑用单调队列存储 <span class="math inline">\(\min/\max\{ds[j]\}，j \in[L(i),R(i)]\)</span>
。单调队列可用于数组上的滑动窗口，此处 <span class="math inline">\(j
\in[L(i),R(i)]\)</span> 也是一个滑动窗口，求滑动窗口内的最值。</p>
<p>我们可在遍历 <span class="math inline">\(i\)</span> 的同时计算当前的
<span class="math inline">\(\min/\max\{ds[j]\}，j\in
[R(i-1)+1,R(i)]\)</span> ，将当前计算出的值逐个压入单调队列。</p>
<ul>
<li>如果是当前的最值，就将前面计算的值全部弹走，队首为该最值</li>
<li>如果不是当前的最值，压入队尾，作为未来可能的最值。</li>
<li>检查队首的值是否在滑动窗口范围外，将 <span class="math inline">\(ds[j]，j\in [1，R(i-1)]\)</span> 弹出队首。</li>
</ul>
<p>实际中，单调队列储存的值为 <span class="math inline">\(ds\)</span>
的下标 <span class="math inline">\(j\)</span>， <span class="math inline">\(ds[j]= dp[j]+b[j]\)</span> 可以不额外存储。</p>
<h3 id="单调队列优化模板题">单调队列优化模板题</h3>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2627">P2627 [USACO11OPEN]
Mowing the Lawn G</a></p>
<p>题目来源：《算法竞赛》P368</p>
<p>问题概述：有一个包括 <span class="math inline">\(n\)</span>
个正整数的序列，第 <span class="math inline">\(i\)</span> 个整数为 <span class="math inline">\(E_i\)</span> ，给定一个整数 <span class="math inline">\(k\)</span>
，找这样的子序列，如果子序列中的数在原序列中连续，则连续长度不能超过
<span class="math inline">\(k\)</span>
。对于子序列求和，问所有子序列中最大的和是多少？</p>
<p>简要题解：</p>
<p>设 <span class="math inline">\(dp[i]\)</span> 为前 <span class="math inline">\(i\)</span>
个整数的最大子序列和，则状态转移方程为：</p>
<p><span class="math display">\[
dp[i] = \max \{dp[j-1]+sum[i]-sum[j]\},\quad  j \in [i-k,i]
\]</span></p>
<p>其中 <span class="math inline">\(sum[i]\)</span> 是前缀和，<span class="math inline">\(sum[i]-sum[j]\)</span> 求的是 <span class="math inline">\([i-k,i]\)</span> 区间和。</p>
<p>根据单调队列优化：</p>
<p><span class="math display">\[
\begin{align}
dp[i] &amp;= \max \{dp[j-1]-sum[j]\}+sum[i],\quad  j \in [i-k,i] \\
&amp;=\max \{ds[j]\}+sum[i]
\end{align}
\]</span></p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100007</span>;<br>ll n, k, e[N], sum[N], dp[N];<br>ll ds[N];<br><span class="hljs-comment">// 单调队列，为了简便没有写为循环队列，head</span><br><span class="hljs-comment">// 由于这里是求最大值，故 ds[q[tail]] &lt; ds[j] 为从队首到队尾的单调递减队列</span><br><span class="hljs-comment">// 如果是求最小值，则为从队首到队尾的单调递增队列，即 ds[q[tail]] &gt; ds[j]</span><br><span class="hljs-comment">// q[head] &lt; j - k 为了保证队列中的元素都在滑动窗口[i - k, i] (j == i)内</span><br><span class="hljs-comment">// head 指向队首元素，tail指向队尾元素，当队中没有元素时，tail = head - 1</span><br><span class="hljs-type">int</span> q[N], head = <span class="hljs-number">0</span>, tail = <span class="hljs-number">-1</span>;<br><span class="hljs-function">ll <span class="hljs-title">monoQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> j)</span> </span>&#123;<br>    ds[j] = dp[j - <span class="hljs-number">1</span>] - sum[j];<br>    <span class="hljs-keyword">while</span> (head &lt;= tail &amp;&amp; ds[q[tail]] &lt; ds[j])<br>        tail--;  <span class="hljs-comment">// ds[j]从队尾进入，经过比它小的值就删去</span><br>    q[++tail] = j;<br>    <span class="hljs-keyword">while</span> (head &lt;= tail &amp;&amp; q[head] &lt; j - k)<br>        head++;<br>    <span class="hljs-keyword">return</span> ds[q[head]];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    sum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; e[i];<br>        sum[i] = sum[i - <span class="hljs-number">1</span>] + e[i];<br>    &#125;<br>    <span class="hljs-built_in">monoQueue</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 初始化单调队列 ds[0] = dp[-1] - sum[0] = 0 - 0 = 0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        dp[i] = <span class="hljs-built_in">monoQueue</span>(i) + sum[i];<br>    cout &lt;&lt; dp[n];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="d1d-斜率凸壳优化">2 (1D/1D) 斜率/凸壳优化</h2>
<h3 id="概念-1">概念</h3>
<p><strong>斜率/凸壳优化特征状态方程：</strong></p>
<p><span class="math display">\[
dp[i]=\min \{dp[j]-a[i]d[j]\}, \quad j \in [0,i-1], \quad a[i] \le
a[i+1], \quad d[j]\le d[j+1]
\]</span></p>
<p>特点：存在一个既有 <span class="math inline">\(i\)</span> 又有 <span class="math inline">\(j\)</span> 的项 <span class="math inline">\(a[i]d[j]\)</span> ，并且 <span class="math inline">\(a[i]\)</span> 和 <span class="math inline">\(d[j]\)</span> 都是单调不减， <span class="math inline">\(j \in [0,i-1]\)</span> 。</p>
<p><span class="math display">\[
\begin{align}
\because dp[i] &amp;= dp[j] - a[i]d[j] \\
\therefore dp[j] &amp;= a[i]d[j] + dp[i] \\
\end{align}
\]</span></p>
<p><span class="math display">\[
设~y=dp[j],x=d[j],k=a[i],b=dp[i],~得:\\
y=kx+b
\]</span></p>
<p>其中 <span class="math inline">\(b=dp[i]\)</span>
是我们要求的值，并且要是最小值，故最小化 <span class="math inline">\(dp[i]\)</span> 的问题转化为：</p>
<ul>
<li>对于 <span class="math inline">\(j \in [0,i)\)</span> 中的不同的
<span class="math inline">\(j\)</span> ，会产生一系列点 <span class="math inline">\((d[j],dp[j])=(x_j,y_j)\)</span>
分布在平面上。</li>
<li>寻找 <span class="math inline">\((x_j,y_j)\)</span> ，在斜率 <span class="math inline">\(k=a[i]\)</span> 的情况下，能够使截距 <span class="math inline">\(b=dp[i]\)</span> 达到最小值。</li>
</ul>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E3%80%90DP%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/monoqueue1_200-17071392712861.svg" srcset="/img/loading.gif" lazyload alt="寻找最小的 b">
<figcaption aria-hidden="true">寻找最小的 <span class="math inline">\(b\)</span></figcaption>
</figure>
<p>通过构造“<strong>凸壳</strong>”的技巧，我们可以很快寻找到使截距 <span class="math inline">\(b=dp[i]\)</span> 达到最小值的 <span class="math inline">\((x_j,y_j)\)</span>。</p>
<p>我们设这个最优点为 <span class="math inline">\(P_i=(x_j,y_j)\)</span>
（下标为 <span class="math inline">\(i\)</span> 表示它是根据 <span class="math inline">\(k=a[i]\)</span> 来寻找的）</p>
<p>这个点一定在下凸壳上，并且它与前一个点的斜率 <span class="math inline">\(\le k\)</span> ，与后一个点的斜率 <span class="math inline">\(\ge k\)</span>
（也可能是是凸壳中第一个或最后一个点，当所有线段的斜率都 <span class="math inline">\(\le k\)</span> 或 <span class="math inline">\(\ge
k\)</span>）。</p>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E3%80%90DP%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/monoqueue2_200-17071392712872.svg" srcset="/img/loading.gif" lazyload alt="下凸壳">
<figcaption aria-hidden="true">下凸壳</figcaption>
</figure>
<p>当我们随着 <span class="math inline">\(i\)</span> 的遍历，计算最新的
<span class="math inline">\(j \in [0,i)\)</span> 对应的 <span class="math inline">\((x_j,y_j)\)</span>
并加入到平面上时，凸壳上的点会不断更新，以确保它一直是凸壳。比如点 3 在
<span class="math inline">\(i = 3\)</span>
时是最新的点，它与1、2、3组成凸壳，但是当 <span class="math inline">\(i
= 4\)</span> 时，随着点 4 的加入，点 3 被排除，1、2、4重新组成凸壳。</p>
<mydetails>
<summary>
<summary-title>Algorithm</summary-title><summary-subtitle>凸包构造算法</summary-subtitle>
</summary>
<p>这种算法为计算几何中一种简单的凸包算法：安德鲁算法（Andrew's
Algorithm）</p>
<p>这个是利用单调队列以及斜率的单调性来得到凸包。</p>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E3%80%90DP%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/R6VuVuU-17071392712873.gif" srcset="/img/loading.gif" lazyload alt="Andrew&#39;s Algorithm 构建凸包的过程">
<figcaption aria-hidden="true">Andrew's Algorithm
构建凸包的过程</figcaption>
</figure>
<p>另有别的凸包构建算法：Graham’s Scan</p>
<p>先找到最左下的点(y
最小的最左边的点)，计算其他点以该点为原点的极角，并用极角对点进行排序。同样用一个单调队列来维护凸包上的点。</p>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E3%80%90DP%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/5rtTjsI-17071392712874.gif" srcset="/img/loading.gif" lazyload alt="Graham’s Scan 构建凸包的过程">
<figcaption aria-hidden="true">Graham’s Scan 构建凸包的过程</figcaption>
</figure>
<p>两者时间复杂度受限于排序，为 <span class="math inline">\(O(n\log
n)\)</span> 。由于这里给出的 <span class="math inline">\(x=d[j]\le
d[j+1]\)</span> ，所以省去了排序的过程。</p>
<p></p></mydetails><p></p>
<p>对于计算 <span class="math inline">\(dp[i] = b_{\min}\)</span>
，我们就在斜率 <span class="math inline">\(k=a[i]\)</span>
的情况下，<strong>从左到右遍历</strong>凸壳上的点寻找最优 <span class="math inline">\((x_j,y_j)\)</span> 。该项时间复杂度为 <span class="math inline">\(O(n)\)</span>。考虑 <span class="math inline">\(i\)</span> 有 <span class="math inline">\(n\)</span> 次循环，总时间复杂度为 <span class="math inline">\(O(n^2)\)</span>。</p>
<blockquote>
<p>到目前为止，相较于普通的DP方法，我们仅仅是用凸壳来改进了 <span class="math inline">\((x_j,y_j)\)</span>
的一部分搜索范围（即只搜索凸壳上的点）。最好情况下是 $(n) $
，即凸壳上总是只有 1 个点；在最坏情况下，所有点都在凸壳上，时间复杂度为
$(n^2) $</p>
<p>怎么进一步优化呢？</p>
<p>想要优化，那么我们必须要让 <span class="math inline">\(k=a[i]\)</span> 以及 <span class="math inline">\(x=d[j]\)</span> 满足一些性质，让我们能够以优于
<span class="math inline">\(O(n)\)</span>
的时间在凸壳找到最优决策点。最常见的性质为单调性。下面从单调性这一性质展开优化。</p>
</blockquote>
<h3 id="k-单调不减x-单调不减单调队列">(1) <span class="math inline">\(k\)</span> 单调不减，<span class="math inline">\(x\)</span> 单调不减：单调队列</h3>
<p>如果最开始给出的特征状态方程还有这样的性质：</p>
<p><span class="math display">\[
a[i] \le a[i+1], \quad d[j]\le d[j+1]
\]</span></p>
<ul>
<li><p><span class="math inline">\(k=a[i]\)</span>
是单调不减的。假设上一轮斜率是 <span class="math inline">\(k_{i-1}\)</span> ，找到了最优点 <span class="math inline">\(P_{i-1}\)</span>，下一轮的斜率 <span class="math inline">\(k_i \ge
k_{i-1}\)</span>，此时凸壳上的<strong>最优点 <span class="math inline">\(P_{i}\)</span> 必然在 <span class="math inline">\(P_{i-1}\)</span>
的右侧或它本身</strong>。因此凸壳上 <span class="math inline">\(P_{i-1}\)</span>
之前的点不用遍历了，直接跳过。</p>
<blockquote>
<p>凸壳上 <span class="math inline">\(P_{i-1}\)</span>
之前的点也可以删除，即使新加入的点使得之前的凸壳发生了变化，我们搜索的起始点也没有变化</p>
</blockquote></li>
<li><p><span class="math inline">\(x=d[j]\)</span> 也是单调不减的。说明
<span class="math inline">\((x_j,y_j)\)</span> 在平面上从左往右是按照
<span class="math inline">\(j\)</span>
从小到大的顺序来分布的。也就是说<strong>新加入的点 <span class="math inline">\((x_j,y_j)\)</span>
只会在最右侧，不会跑到左边破坏我们的凸壳</strong>。这样就保证了我们只需要根据凸壳末端的点和新加入的点进行斜率比较即可决定凸壳的更新方式。（与此同时，也支持形成单调队列的结构）</p></li>
</ul>
<p>因此，我们只需用<strong>单调队列</strong>在点一个个被加入时维护凸壳，即可根据上一轮的
<span class="math inline">\(P_{i-1}\)</span> 以 <span class="math inline">\(O(1)\)</span> 找到这一轮的 <span class="math inline">\(P_{i}\)</span> 。</p>
<blockquote>
<p>因为每轮只有一个点新加入平面，我们从上一轮的最优点开始往凸壳右边找，很快就能找到。
而且最终查询的点数小于凸壳上所有曾经加入的点数。</p>
</blockquote>
<p>最终，<span class="math inline">\(i\)</span> 的遍历为 <span class="math inline">\(O(n)\)</span> ，每次寻找 <span class="math inline">\(dp[i] = b_{\min}\)</span> 在凸壳上对应的最优点
<span class="math inline">\(P_{i}\)</span> 的时间为 <span class="math inline">\(O(1)\)</span> ，总时间复杂度为 <span class="math inline">\(O(n)\)</span> 。</p>
<blockquote>
<p>思考：如果两者都是单调不增呢？</p>
<p><span class="math display">\[
dp[i]=\min \{dp[j]-a[i]d[j]\}, \quad j \in [0,i-1],\quad a[i] \ge
a[i+1], \quad d[j]\ge d[j+1]
\]</span></p>
<p>这样，其实依然是下凸壳，只是从<strong>点在平面上的分布</strong>来看，遍历顺序（
<span class="math inline">\([0,i-1]\)</span>
）从原来的【由左到右】变为了【由右到左】而已。我们维护凸壳的时候，要按照斜率递减的方式维护。</p>
</blockquote>
<mydetails>
<summary>
<summary-title>More</summary-title><summary-subtitle>斜率优化+单调队列的另外一种视角</summary-subtitle>
</summary>
<p><span class="math display">\[
\begin{align}
f(i)&amp;=min\{g(j)+p*a(i)^2 + q*b(j)^2 + r*a(i)*b(j) + C\} \\
(f(i)-p*a(i)^2)&amp;=(g(j)+q*b(j)^2)+(r*a(i)*b(j))+C\\
(g(j)+q*b(j)^2)&amp;=(f(i)-p*a(i)^2-C)-(r*a(i)*b(j))\\
Y(j)&amp;=B(i)+K(i)X(j)\\
Y(j-1)&amp;=B(i)+K(i)X(j-1)\\
K(i)&amp;=\frac{Y(j)-Y(j-1)}{X(j)-X(j-1)}\\
F(i)&amp;=\min\{G(j)\} + W(i),W(i)=0
\end{align}
\]</span></p>
<p>通过单调队列维护 <span class="math inline">\(G(j)=\frac{Y(j)-Y(j-1)}{X(j)-X(j-1)}\)</span> 实现
<span class="math inline">\(O(n)\)</span> 时间复杂度。</p>
<p></p></mydetails><p></p>
<p><strong>斜率/凸壳优化模板代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-comment">// 删除凸壳上在最优点Pi左边的点，剩下的队列的队首即为最优点Pi</span><br>    <span class="hljs-keyword">while</span> (head &lt; tail &amp;&amp; <span class="hljs-built_in">slope</span>(q[head], q[head+<span class="hljs-number">1</span>]) &lt; k) head++;<br>    <span class="hljs-comment">// 根据最优点Pi计算dp[i] = b_min</span><br>    <span class="hljs-type">int</span> j = q[head];<br>    dp[i] = ...;<br>    <span class="hljs-comment">// 下一轮的点(x_j,y_j)(j = i)加入图中，并更新凸壳（因为j &lt; i，所以这里是下一轮）</span><br>    <span class="hljs-keyword">while</span> (head &lt; tail &amp;&amp; <span class="hljs-built_in">slope</span>(i, q[tail<span class="hljs-number">-1</span>]) &lt; <span class="hljs-built_in">slope</span>(q[tail<span class="hljs-number">-1</span>], q[tail])) tail--;<br>    q[++tail] = i; <span class="hljs-comment">// 加入队尾</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面的代码计算的顺序和前面我们描述的过程不太一样，主要是因为 <span class="math inline">\(0 \le j &lt; i\)</span>。</p>
<h4 id="斜率优化单调队列模板题">斜率优化+单调队列模板题</h4>
<h4 id="print-article-hdu3507">1. <a target="_blank" rel="noopener" href="https://vjudge.net/problem/HDU-3507#author=yizhexu">Print Article
HDU3507</a></h4>
<p><span class="math inline">\(\texttt{Description}\)</span></p>
<p>打印一篇有 <span class="math inline">\(N\)</span>
个字的文章，每个字i的打印成本是 <span class="math inline">\(C_i\)</span>。此外，在一行中打印 <span class="math inline">\(k\)</span> 个字将花费: <span class="math inline">\((\sum\limits_{i=1}^{k} C_i)^2 + M\)</span>。 <span class="math inline">\(M\)</span>
是一个常数。你的任务是找到一种最佳的打印方式，使得总的打印成本最小。</p>
<p><span class="math inline">\(\texttt{Input}\)</span></p>
<p>有很多测试用例。对于每个测试用例，第一行有两个数字<span class="math inline">\(N\)</span>和<span class="math inline">\(M\)</span>（0 ≤ n ≤ 500000，0 ≤ M ≤
1000）。然后，下面的第<span class="math inline">\(2\)</span>到第<span class="math inline">\(N + 1\)</span>行有N个数字。输入以<span class="math inline">\(EOF\)</span>结束。</p>
<p><span class="math inline">\(\texttt{Output}\)</span></p>
<p>对于每个测试用例，输出一个整数，表示最小的打印成本。</p>
<h5 id="斜率优化单调队列题解">斜率优化+单调队列题解</h5>
<p>设 <span class="math inline">\(dp[i]\)</span> 为前 <span class="math inline">\(i\)</span> 个单词的最低成本，<span class="math inline">\(sum[i]\)</span> 为前缀和。</p>
<p><span class="math display">\[
\begin{align*}
     \because dp[i] &amp;= \min(dp[j] + (sum[i] - sum[j])^2 + M) \\
       &amp;= \min(dp[j] + sum[i]^2 - 2 \times sum[i] \times sum[j] +
sum[j]^2 + M) \\
\therefore(dp[i] - sum[i]^2)  &amp;= \min(dp[j] + sum[j]^2 - 2 \times
sum[i] \times sum[j]) + M \\
     &amp;= (dp[j] + sum[j]^2) - (2 \times sum[i] \times sum[j]) + M \\
\therefore(dp[j] + sum[j]^2)  &amp;= (2 \times sum[i] \times sum[j]) +
(dp[i] - sum[i]^2) - M \\
\end{align*}
\]</span></p>
<p><span class="math display">\[
设~ y = dp[j] + sum[j]^2,~ x = sum[j],~ k = 2 \times sum[i],~ b = dp[i]
- sum[i]^2 - m,~则有：
\]</span></p>
<p><span class="math display">\[
y=kx+b
\]</span></p>
<p><span class="math inline">\(x=sum[j]\)</span> 和 <span class="math inline">\(k=2\times sum[i]\)</span>
都是单调不减，满足斜率优化的要求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">500007</span>;<br><span class="hljs-type">int</span> n, m, c[N], sum[N], dp[N];  <span class="hljs-comment">// dp[i] 表示前 i 个字的最小打印成本</span><br><span class="hljs-type">int</span> q[N], head, tail;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> K(p) (2 * sum[i])</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> X(p) (sum[p])</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Y(p) (dp[p] + sum[p] * sum[p])</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> B(p) (dp[i] - sum[i] * sum[i] - m)</span><br><span class="hljs-comment">// le -&gt; less or equal (&lt;=) , ge -&gt; greater or equal (&gt;=)</span><br><span class="hljs-comment">// lt -&gt; less than (&lt;) , gt -&gt; greater than (&gt;)</span><br><span class="hljs-comment">// 以下两行可以避免除法（除法会有误差和除数为0的情况）</span><br><span class="hljs-comment">// 一定要注意p1和p2的顺序，p1在p2的右边，即p1的x坐标大于p2的x坐标，否则斜率算的是反的</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> slope_le_k(p1, p2 ,k) ((Y(p1) - Y(p2)) &lt;= (X(p1) - X(p2)) * (k))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> k1_le_k2(p1, p2, p3, p4) ((Y(p1) - Y(p2)) * (X(p3) - X(p4)) &lt;= (Y(p3) - Y(p4)) * (X(p1) - X(p2)))</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; m) &#123;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        sum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            cin &gt;&gt; c[i];<br>            sum[i] = sum[i - <span class="hljs-number">1</span>] + c[i];<br>        &#125;<br>        head = <span class="hljs-number">1</span>, tail = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化单调队列: 放入一个元素0 (也抛弃了q[0]，选择下标从1开始)</span><br>        q[tail] = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 这里是 j == 0的情况，只有一个点，所以不需要判断斜率直接放入</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-comment">// 这里不能是 head &lt;= tail ！！！因为至少要有两个元素才能计算斜率</span><br>            <span class="hljs-comment">// 并且也可能是特殊情况：当所有线段的斜率都 &lt;= k 时，此时队列必须剩下一个元素</span><br>            <span class="hljs-comment">// 注意q[head + 1], q[head]的顺序，确保斜率不要反了！！！</span><br>            <span class="hljs-keyword">while</span> (head &lt; tail &amp;&amp; <span class="hljs-built_in">slope_le_k</span>(q[head + <span class="hljs-number">1</span>], q[head], <span class="hljs-built_in">K</span>(i))) head++;   <br>            <span class="hljs-type">int</span> j = q[head];    <span class="hljs-comment">// 队首的 j 是最优决策点</span><br>            dp[i] = dp[j] + (sum[i] - sum[j]) * (sum[i] - sum[j]) + m;  <span class="hljs-comment">// 计算 dp[i]</span><br>            <span class="hljs-comment">// 下一轮的点(x_j,y_j)(j = i)加入图中，并更新凸壳（因为j &lt; i，所以这里是下一轮）</span><br>            <span class="hljs-comment">// 由于队列中的点都是凸包上的点，所以这里只需要判断队尾的点是否在凸包外即可</span><br>            <span class="hljs-keyword">while</span> (head &lt; tail &amp;&amp; <span class="hljs-built_in">k1_le_k2</span>(q[tail], i, q[tail - <span class="hljs-number">1</span>], q[tail])) tail--;<br>            q[++tail] = i;<br>        &#125;<br>        cout &lt;&lt; dp[n] &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<mydetails>
<summary>
<summary-title>More</summary-title><summary-subtitle>斜率优化推导练习</summary-subtitle>
</summary>
<hr>
<p><strong>练习1</strong></p>
<p><span class="math display">\[
f(i)=\min\{g(j)+(a(i)+b(j))^3\}
\]</span></p>
<p>推导为 <span class="math inline">\(y=kx+b\)</span> 形式：</p>
<p><span class="math display">\[
\begin{align}
f_i&amp;=g_j+a_i^3+3a_i^2b_j+3a_ib_j^2+b_j^3\\
f_i-a_i^3&amp;=g_j+3a_i^2b_j+3a_ib_j^2+b_j^3\\
\end{align}
\]</span></p>
<hr>
<p><strong>练习2</strong></p>
<p><span class="math display">\[
dp[i]=\min\limits_{j=1}^{i-1}\{a[i]\cdot x[j]+b[i]\cdot y[j]\} +
w[i],~其中~x[j],y[j]~可由~dp[j]~在O(1)时间内唯一确定
\]</span></p>
<p>推导为 <span class="math inline">\(y=kx+b\)</span> 形式：</p>
<p><span class="math display">\[
\begin{align}
\frac{dp[i]}{a[i]}&amp;=x[j]+\frac{b[i]}{a[i]}\cdot y[j] +
\frac{w[i]}{a[i]}\\
x[j]&amp;=-\frac{b[i]}{a[i]}\cdot
y[j]+\left(\frac{dp[i]}{a[i]}-\frac{w[i]}{a[i]}\right)\\
\end{align}
\]</span></p>
<hr>
<p></p></mydetails><p></p>
<h3 id="k-无单调性x-单调不减二分单调栈">(2) <span class="math inline">\(k\)</span> 无单调性，<span class="math inline">\(x\)</span> 单调不减：二分单调栈</h3>
<p>即：</p>
<p><span class="math display">\[
dp[i]=\min \{dp[j]-a[i]d[j]\}, \quad j \in [0,i-1], \quad
a[i]~\text{无单调性},\quad d[j]\le d[j+1]
\]</span></p>
<ul>
<li><span class="math inline">\(k=a[i]\)</span>
无单调性。这意味着我们无法从上一轮的最优点开始，直接往后在凸壳上找到这一轮的最优点。也就是说，必须搜索当前的整个凸壳！</li>
<li><span class="math inline">\(x=d[j]\)</span>
单调不减。说明凸壳的维护还是按照（1）中的 Andrew 算法即可，</li>
</ul>
<p>此时我们必须搜索整个凸壳了，计算凸壳上每两个点构成的直线的斜率。根据（1）中的分析，我们知道，凸壳上的这个“斜率”是单调不减的，对于有序数列的搜索，可以使用二分搜索来优化至
<span class="math inline">\(O(\log n)\)</span> ，我们总共要计算 n 次
<span class="math inline">\(dp[i]\)</span> ，所以总共的时间复杂度为
<span class="math inline">\(O(n\log n)\)</span> 。</p>
<p>因为没有对队首的操作，<strong>单调队列成了单调栈</strong>。</p>
<p>唯一要注意的就是：凸壳上有<strong>多点共线</strong>的情况。二分搜索是搜索不到共线的中间的点的，只能搜索到两边的点，并且取哪一边需要看题目的要求如何。</p>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E3%80%90DP%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/monoqueue3_200-17071392712875.svg" srcset="/img/loading.gif" lazyload alt="有多点共线">
<figcaption aria-hidden="true">有多点共线</figcaption>
</figure>
<h3 id="k-单调不减x-无单调性动态凸包">(3) <span class="math inline">\(k\)</span> 单调不减，<span class="math inline">\(x\)</span> 无单调性：动态凸包</h3>
<p>即满足：</p>
<p><span class="math display">\[
a[i] \le a[i+1],\quad d[j]~\text{无单调性}
\]</span></p>
<ul>
<li><p><span class="math inline">\(k=a[i]\)</span>
单调不减。受到动态凸包的影响，用不太上，基本可以忽略。每一轮搜索的斜率单调不减，则可以：</p>
<ul>
<li>如果这一轮加入的点未破坏上一轮的最优点，则从上一轮的最优点开始二分</li>
<li>如果这一轮加入的点破坏了上一轮的最优点，则从该点开始二分</li>
</ul>
<p>但实际上这样做只是优化了一点点常数，没什么必要，我们二分的 <span class="math inline">\(\log n\)</span>
已经足够快了。所以一般忽略这个性质，直接二分即可。</p></li>
<li><p><span class="math inline">\(x=d[j]\)</span>
无单调性。说明凸壳的维护不能使用 Andrew
算法。此时变成了<strong>动态凸包</strong>问题，考虑使用算法：</p>
<ul>
<li>树状数组、线段树优化：参考最长递增子序列（LIS）问题（<span class="math inline">\(dp[i] = max\{dp[j]\}+1\)</span>）。</li>
<li>李超线段树</li>
<li>CDQ分治</li>
<li>set维护凸包</li>
</ul></li>
</ul>
<p>最终基本上是 <span class="math inline">\(O(n\log n)\)</span>
的时间复杂度。</p>
<h3 id="k-无单调性x-无单调性动态凸包">(4) <span class="math inline">\(k\)</span> 无单调性，<span class="math inline">\(x\)</span> 无单调性：动态凸包</h3>
<p>和（3）的情况几乎一样。</p>
<hr>
<h2 id="d1d-决策单调性优化">3 (1D/1D) 决策单调性优化</h2>
<h4 id="概念-2">概念</h4>
<p>决策单调性适用于 1D/1D 方程，意思是我们计算的 <span class="math inline">\(dp[i]\)</span> 的状态维度是 1 维的 <span class="math inline">\([i]\)</span> ，决策点的维度是 1 维的 <span class="math inline">\([j]\)</span> 。</p>
<hr>
<p><strong>特征状态方程 （一）</strong>：</p>
<p><span class="math display">\[
\begin{align}
f(i)&amp;=\min\limits_{1\le j &lt; i}\{g(j)+w(i,j)\} \\
或~f(i)&amp;=\max\limits_{1\le j &lt; i}\{g(j)+w(i,j)\}
\end{align}
\]</span></p>
<p>若 <span class="math inline">\(w(i,j)\)</span> 满足四边形不等式：</p>
<p><span class="math display">\[
\begin{align}
w(a,c)+w(b,d)&amp;\le w(a,d)+w(b,c),\quad a\le b\le c\le d \\
或~w(i,j)+w(i+1,j+1)&amp;\le w(i,j+1)+w(i+1,j),\quad i&lt;i+1\le j
&lt;j+1
\end{align}
\]</span></p>
<p>则可以进行决策单调性优化。</p>
<h4 id="wij-满足区间单调性单调队列">(1) <span class="math inline">\(w(i,j)\)</span> 满足区间单调性：单调队列</h4>
<p>若 <span class="math inline">\(w(i,j)\)</span> 满足区间单调性：</p>
<p><span class="math display">\[
w(b,c) \le w(a,d),\quad a\le b\le c\le d \\
或者~w(i+1,j) \le w(i,j+1)
\]</span></p>
<ul>
<li>速记：<strong>小区间 <span class="math inline">\(\le\)</span>
大区间</strong>，类似于一维的单调递增</li>
</ul>
<p>设 <span class="math inline">\(k(i)\)</span> 为状态 <span class="math inline">\(i\)</span> 的最优决策点（这里的 <span class="math inline">\(k\)</span> 是 <span class="math inline">\(f(i)\)</span> 取得最优情况的 <span class="math inline">\(j\)</span> ，所以用 <span class="math inline">\(k(i)\)</span> 表示），则有：</p>
<p><span class="math display">\[
\begin{align}
k(i-1) \le k(i) \le k(i+1)
\end{align}
\]</span></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P1973">P1973 NOI2011
Noi嘉年华</a></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P3724">P3724
[AHOI2017/HNOI2017] 大佬</a></p>
<h4 id="wij-无区间单调性">(2) <span class="math inline">\(w(i,j)\)</span> 无区间单调性</h4>
<p>类型2</p>
<p>【Done】[BZOJ4709 <a target="_blank" rel="noopener" href="https://www.lydsy.com/JudgeOnline/problem.php?id=4709">Jsoi2011]柠檬</a></p>
<p>【<a target="_blank" rel="noopener" href="https://www.cnblogs.com/flashhu/p/9488184.html">Sol.</a>】[洛谷P3515
<a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P3515">POI2011]Lightning
Conductor</a></p>
<p>【<a target="_blank" rel="noopener" href="https://www.cnblogs.com/flashhu/p/9521094.html">Sol.</a>】[洛谷P1912
<a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P1912">NOI2009]诗人小G</a></p>
<p>【<a target="_blank" rel="noopener" href="https://www.cnblogs.com/flashhu/p/9495839.html">Sol.</a>】<a target="_blank" rel="noopener" href="http://codeforces.com/problemset/problem/868/F">CF868F Yet Another
Minimization Problem</a>（<a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/CF868F">洛谷</a>）（<a target="_blank" rel="noopener" href="https://vjudge.net/problem/CodeForces-868F#author=axs">vjudge</a>）</p>
<h2 id="d1d-wqs带权二分优化">4 (2D/1D) WQS带权二分优化</h2>
<p><strong>特征状态方程</strong>：</p>
<p><span class="math display">\[
\begin{align}
&amp;f(i,j)=\min/\max\{g(i,k)+w(i,j)\},\quad j \in [1,i],\quad
w(i,j)~无明显性质 \\\\
&amp;令~i~为常数，f(j)~为凸函数，即~f(j)-f(j-1)\le
f(j+1)-f(j)~或~f(j)-f(j-1)\ge f(j+1)-f(j)~\\\\
&amp;令~j \to +\infin，f(i)=\min/\max\{g(i)+w(i,j)\}
~能在~O(n)~时间内计算。
\end{align}
\]</span></p>
<h3 id="题目类型">题目类型</h3>
<p>给定 <span class="math inline">\(N\)</span> 个物品，每个物品有其价值
<span class="math inline">\(w\)</span>（<span class="math inline">\(w\)</span> 可以为负数）
，<strong>限制</strong>从其中选取 <span class="math inline">\(M\)</span>
（<span class="math inline">\(m \le
n\)</span>）个物品，求最大选取总价值。</p>
<h3 id="朴素dp思路">朴素DP思路</h3>
<p>（这里看似可以直接排序 <span class="math inline">\(O(n\log
n)\)</span> ，但是题目中价值 <span class="math inline">\(w\)</span>
往往较复杂，不能简单的排序后贪心）</p>
<p>设 <span class="math inline">\(f(i,j)\)</span> 为前 <span class="math inline">\(i\)</span> 个物品中，选取 <span class="math inline">\(j\)</span>
个物品的最大价值。则状态转移方程为：</p>
<p><span class="math display">\[
f(i,j)=\max\{f(i-1,j),f(i,j-1)+w(i)\},\quad j \in [1,i]
\]</span></p>
<p>这个朴素版本的做法的时间复杂度是 <span class="math inline">\(O(n^2)\)</span> 。而WQS二分能优化至 <span class="math inline">\(O(n\log n)\)</span> 。</p>
<h3 id="wqs二分解题思路">WQS二分解题思路</h3>
<h4 id="检查-ficj-关于-j-的凸性">1. 检查 <span class="math inline">\(f(i=C,j)\)</span> 关于 <span class="math inline">\(j\)</span> 的凸性</h4>
<p>既然要优化，那么一定是利用了函数的某种性质，这里也是利用的<strong>凹凸性</strong>。</p>
<p>将 <span class="math inline">\(f(i,j)\)</span> 看作以选取物品 <span class="math inline">\(j\)</span> 为自变量的函数，<span class="math inline">\(i\)</span> 为其中的常数，把 <span class="math inline">\(j\)</span> 改写为 <span class="math inline">\(x\)</span> ，则有函数 <span class="math inline">\(f(i=C,x)\)</span> 。</p>
<p>注意到 <span class="math inline">\(f(i=C,x)\)</span>
为<strong>上凸函数</strong>，即满足：</p>
<p><span class="math display">\[
f(x-1)-f(x) \ge f(x) - f(x+1)
\]</span></p>
<p>这个很容易想到，我们每次选取物品，必然选最好的，下一轮选择肯定只能选到没那么好的或同样好的。这增长率不就单调不减了嘛。</p>
<h4 id="简化问题不限制-j-时的-fij不限制-很好算">2. 简化问题：不限制
<span class="math inline">\(j\)</span> 时的 <span class="math inline">\(f(i,j=不限制)\)</span> 很好算</h4>
<p><strong>假设不限制选取物品个数</strong>，求最大选取总价值。当然全都选就是
<span class="math inline">\(N\)</span> 个。则：</p>
<p><span class="math display">\[
f(i,x=不限制)=\max\{f(i-1),f(i-1)+w(i)\}, \quad i \in [1,N]
\]</span></p>
<p>这个是一个 <span class="math inline">\(O(n)\)</span>
的过程。最终答案为 <span class="math inline">\(f(i=N)\)</span> 。</p>
<p>此时选取了 <span class="math inline">\(0\le t \le N\)</span>
个物品。虽然没有指定一定要选几个，但只选 <span class="math inline">\(t\)</span>
个是最优的，剩下的物品是负数，不选。所以 <span class="math inline">\(f(i=N,x=t)=f(i=N)\)</span> 。这样就以 <span class="math inline">\(O(n)\)</span> 时间就算出了 <span class="math inline">\(f(N,t)\)</span> 。</p>
<p>要是 <span class="math inline">\(t=M\)</span> 的话，岂不是直接算出了
<span class="math inline">\(f(N,M)\)</span> ！？确实如此，但可惜 <span class="math inline">\(f(i=C,x)\)</span> 的最大值点不一定是 <span class="math inline">\(M\)</span> 。</p>
<h4 id="凸函数加减-kx-凸性不变最值点单调移动">3. 凸函数：加减 <span class="math inline">\(kx\)</span> 凸性不变，最值点单调移动</h4>
<p>现在我们来观察<strong>凸函数</strong>的性质：（以二次函数为例）</p>
<p><strong>“用原凸函数构造新凸函数，用新凸函数的最值点，可以反求原凸函数上横坐标相同的点。”</strong></p>
<p><strong>“而凸函数的最值点很好计算，进而加速了原凸函数上任意一点的计算。”</strong></p>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E3%80%90DP%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/WQS%E4%BA%8C%E5%88%86-%E4%BB%A5%E4%BA%8C%E6%AC%A1%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BE%8B.gif" srcset="/img/loading.gif" lazyload alt="WQS二分-以二次函数为例">
<figcaption aria-hidden="true">WQS二分-以二次函数为例</figcaption>
</figure>
<p>在二次函数 <span class="math inline">\(y=ax^2+bx+c\)</span>
中，最值点的横坐标为 <span class="math inline">\(t=-\frac{b}{2a}\)</span> 。给函数减去 <span class="math inline">\(kx\)</span> 相当于减小 <span class="math inline">\(b\)</span> 的值，此时最值点的横坐标增大。所以
<span class="math inline">\(F(x)=f(x)-kx\)</span> 的最值点横坐标 <span class="math inline">\(t&#39;\)</span> 关于 <span class="math inline">\(k\)</span> 是单调的。</p>
<p>当我们遍历所有的 <span class="math inline">\(k\)</span>
值，就可通过不同的 <span class="math inline">\(F_{max}(x)=F(t)\)</span>
计算出 <span class="math inline">\(f(x)\)</span>
上的所有点。我们通过二分搜索来查找 <span class="math inline">\(F_{max}(x)=F(t=M)\)</span> 对应的 <span class="math inline">\(k\)</span> 值，即可得到 <span class="math inline">\(f(x=M)\)</span> 。如果这里常量 <span class="math inline">\(i=N\)</span> ，则得到了 <span class="math inline">\(f(N,M)\)</span> 。</p>
<blockquote>
<p>实际上，所有与 <span class="math inline">\(f(x)\)</span> 相交的直线
<span class="math inline">\(y=kx+F(x)\)</span> 构成了 <span class="math inline">\(F(x)\)</span> 的图像。所以当 <span class="math inline">\(y=kx+F(x)\)</span> 是 <span class="math inline">\(f(x)\)</span> 的切线时，取得 <span class="math inline">\(F(x)\)</span> 的最值点。</p>
</blockquote>
<h4 id="加减-kx-构造新凸函数用其最值点求-fij">4. 加减 <span class="math inline">\(kx\)</span> 构造新凸函数，用其最值点求 <span class="math inline">\(f(i,j)\)</span></h4>
<p>前面是连续函数，下面我们来看<strong>离散型</strong>的函数是否也是这样。</p>
<p>我们利用其<strong>凸性</strong>，用一条直线对其相切：</p>
<p><span class="math display">\[
f(j) = kj + b
\]</span></p>
<p>为了更加直观，写为 <span class="math inline">\(f(x)=kx+b\)</span>
。我们设 <span class="math inline">\(F(x)=b=f(x)-kx\)</span>
。这里设常数 <span class="math inline">\(i=N\)</span>。</p>
<p>图中 <span class="math inline">\(f(N,x)\)</span> 上的每个点都需要
<span class="math inline">\(O(n^2)\)</span> 的时间计算得出。如果我们计算
<span class="math inline">\(f(N,x=不限制)\)</span> ，就是 <span class="math inline">\(O(n)\)</span> 。</p>
<p>是否有办法让 <span class="math inline">\(f(N,x)\)</span>
上任意一点的计算速度和 <span class="math inline">\(f(N,x=不限制)\)</span> 一样快？</p>
<p>我们发现可以利用<strong>切点</strong>来计算 <span class="math inline">\(f(N,x)\)</span> 。令 <span class="math inline">\(f(N,x)=kx+b\)</span> ，截距 <span class="math inline">\(b=f(N,x)-kx=F(N,x)\)</span> 。</p>
<p>假设 <span class="math inline">\(x=t\)</span> 时取得 <span class="math inline">\(F(N,x)\)</span> 的最大值，此时 <span class="math inline">\(b_{max}=F_{max}(N,x)=F(N,t)\)</span> 就是 <span class="math inline">\(f(N,x)\)</span> 的切线的截距。根据计算得出的切线
<span class="math inline">\(y=kx+b_{max}\)</span> ，我们就可以计算得到
<span class="math inline">\(f(t)=kt+b_{max}\)</span> 。</p>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E3%80%90DP%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/WQS_%E4%BF%AE%E6%AD%A3_%E7%9B%B4%E7%BA%BF%E4%B8%8E%E5%87%B8%E5%87%BD%E6%95%B0.svg" srcset="/img/loading.gif" lazyload alt="计算 $F_{max} 相当于做一堆与 f(N,x) 相交、斜率为 k 的直线，取其中截距 b 最大的直线（这个就是切线）">
<figcaption aria-hidden="true">计算 $F_{max} 相当于做一堆与 <span class="math inline">\(f(N,x)\)</span> 相交、斜率为 <span class="math inline">\(k\)</span> 的直线，取其中截距 <span class="math inline">\(b\)</span> 最大的直线（这个就是切线）</figcaption>
</figure>
<p>现在我们思考 <span class="math inline">\(F(N,x=不限制)\)</span>
的情况：</p>
<p>我们计算 <span class="math inline">\(F(N,x=不限制)\)</span>
的最优值，那么它自然一定是 <span class="math inline">\(F(N,x)\)</span>
的最大值。并且通过证明可知 <span class="math inline">\(t \in
[1,N]\)</span> 。简单的高中方法证明如下：</p>
<p>$$ <span class="math display">\[\begin{align}
设&amp;~f(x)~为前~N~个物品中取~x~个物品时的最大总价值。这里不再把~N~写在函数参数括号中。\\
\because&amp;~~~f(x)-f(x-1)\ge f(x+1)-f(x)。\\
\therefore&amp;~~f(x)~为上凸函数，f&#39;&#39;(x)\le 0。\\
设&amp;~F(x)=f(x)-kx,~~F_{max}(x)=F(t)。
\\则&amp;~F&#39;(x)=f&#39;(x)-k，F&#39;&#39;(x)=f&#39;&#39;(x)\le
0，F(x)~也为上凸函数。\\


\\
对&amp;~f&#39;(x)~进行分类讨论:\\
①&amp;~~f&#39;(1)\lt k,~~f&#39;(N)\gt k \\
&amp;~~由于~f&#39;(x)~单调不增，不成立，舍去。\\

\\
②&amp;~~f&#39;(1)\lt k,~~f&#39;(N)\le k \\
&amp;~~由于~f&#39;(x)~单调不增，故~f&#39;(x)&lt;k。\\
\therefore&amp;~~~F&#39;(x)&lt; 0,~F(x)~单调递减。\\
\therefore&amp;~~~F(t)=F_{max}(x)=F(1)\\

\\
③&amp;~~f&#39;(1)\ge k,~~f&#39;(N)\gt k \\
&amp;~~~由于~f&#39;(x)~单调不增，故~f&#39;(x)&gt;k\\
\therefore&amp;~~~F&#39;(x)&gt;0,~F(x)~单调递增。\\
\therefore&amp;~~~F(t)=F_{max}(x)=F(N)\\

\\
④&amp;~~f&#39;(1)\ge k,~~f&#39;(N)\le k \\
\therefore&amp;~~~F&#39;(1)=f&#39;(1)-k \ge 0,~~F&#39;(N)=f&#39;(N)-k
\le 0\\
\therefore&amp;~~~ 由零点定理可得~F(x)~极大值点~t \in[1,N]。\\
\\
综&amp;上所述，F(x)的极大值点~t \in[1,N]。

\end{align}\]</span> $$</p>
<p>所以：</p>
<p><span class="math display">\[
\begin{align}
F_{max}(N,x)&amp;=F(N,t)=F(N,x=不限制),\quad t \in [1,N]
\end{align}
\]</span></p>
<p>我们算出了该 <span class="math inline">\(k\)</span> 值下的 <span class="math inline">\(F_{max}(N,x)\)</span> 之后，此时 <span class="math inline">\(b_{max}=F_{max}(N,x)\)</span> 就是 <span class="math inline">\(f(N,x)\)</span> 的切线的截距。根据切线 <span class="math inline">\(y=kx+b_{max}\)</span> ，就可以得到 <span class="math inline">\(f(N,t)\)</span> 上的切点 <span class="math inline">\((t,kt+b_{max})\)</span> ，也就计算出了 <span class="math inline">\(f(N,t)\)</span> ：</p>
<p><span class="math display">\[
f(N,t)=kt+b_{max}=kt+F(N,t)=kt+F(N,x=不限制)
\]</span></p>
<p>其中 <span class="math inline">\(F(N,x=不限制)\)</span> 的计算是
<span class="math inline">\(O(n)\)</span> 的：（下面 <span class="math inline">\(i\)</span> 意思是前 <span class="math inline">\(i\)</span> 个物品中取不限制个物品）</p>
<p><span class="math display">\[
F(i)=max\{F(i-1),F(i-1)+w(i)-k\},\quad i \in [1,N]
\]</span></p>
<h4 id="二分搜索合适的-k-值得到-fnm">5. 二分搜索合适的 <span class="math inline">\(k\)</span> 值，得到 <span class="math inline">\(f(N,M)\)</span></h4>
<p>这是不是意味着计算 <span class="math inline">\(f(N,x)\)</span>
的速度变成了 <span class="math inline">\(O(n)\)</span>
呢？还不是。因为我们并不能控制 <span class="math inline">\(t=M\)</span>
，所以我们该如何得到想要的 <span class="math inline">\(f(N,M)\)</span>
呢？难道碰运气？</p>
<p>观察 <span class="math inline">\(k\)</span> 取不同值时的 <span class="math inline">\(F(N,x)\)</span> 图像，容易发现<strong>它的极值点
<span class="math inline">\(x=t\)</span> 随 <span class="math inline">\(k\)</span> 的增大而减小</strong>，这是由于 <span class="math inline">\(f(N,x)\)</span>
的凸性导致的。这个也很好证明，但是懒得写了。ψ(｀∇´)ψ</p>
<p>因此，我们可以考虑在一定范围内对 <span class="math inline">\(k\)</span> 进行二分搜索，直到找到某个 <span class="math inline">\(F_k(N,x)\)</span> 的极大值点 <span class="math inline">\(x=t=M\)</span> ，这样我们就获得了 <span class="math inline">\(f(N,M)\)</span> 的值。二分搜索的时间复杂度为 <span class="math inline">\(O(\log n)\)</span> ，每次计算 <span class="math inline">\(F_k(N,x=不限制)\)</span> 的时间复杂度为 <span class="math inline">\(O(n)\)</span> ，总时间复杂度为 <span class="math inline">\(O(n\log n)\)</span> 。</p>
<blockquote>
<p>还可以对WQS二分这样简单理解：每选取一个物品，额外减少 k
的价值，从而间接限制DP对物品的选择数量。</p>
</blockquote>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E3%80%90DP%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/WQS_%E4%BF%AE%E6%AD%A3-17067678589501.svg" srcset="/img/loading.gif" lazyload alt="WQS二分中不同的k值所对应的F极值点">
<figcaption aria-hidden="true">WQS二分中不同的k值所对应的F极值点</figcaption>
</figure>
<blockquote>
<p>对 <span class="math inline">\(k\)</span> 进行二分搜索的范围，最大为
<span class="math inline">\([0,\max\{w(i)\}]\)</span> 。</p>
<p>由于本题 <span class="math inline">\(f(x)\)</span> 的斜率 <span class="math inline">\(f&#39;(N,x)=f(N,x)-f(N,x-1)\)</span>
始终为整数，所以切点 <span class="math inline">\((t,kt+b_{max})\in
f(N,x)\)</span> 的 <span class="math inline">\(k\)</span>
也为整数，因此只需要<strong>整数二分</strong>。如果斜率存在小数，则需要<strong>实数二分</strong>，涉及到浮点数中的精度处理。可以固定实数二分的查找次数，以决定
<span class="math inline">\(k\)</span> 的精度。</p>
</blockquote>
<h4 id="特别注意事项">6. 特别注意事项</h4>
<h5 id="注意多点共线">(1) 注意多点共线</h5>
<p>需要特别特别注意的是你的 <strong>整数二分 和 <span class="math inline">\(F_k(N,x=不限制)\)</span>
的计算要匹配！！！</strong></p>
<p>如果 <strong>F
的最值是多点共线</strong>，我们将不能简单地通过整数二分搜索直接获得<strong>中间</strong>的点，<strong>只能获得端点</strong>。搜索出的
<span class="math inline">\(x=t\)</span> 并不一定等于 <span class="math inline">\(M\)</span>
！！！但是可以由端点计算中间的点，因为它们的 <span class="math inline">\(F\)</span> 的值都是一样的，只是 <span class="math inline">\(f\)</span> 需要加上的 <span class="math inline">\(kx\)</span> 不同。</p>
<p>当我们计算出共线的某一个端点的 <span class="math inline">\(F_{max}(N,x)\)</span>
时，则可以计算出这条线段上的所有 <span class="math inline">\(f(N,x)\)</span> 的值，具体见模板题。</p>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E3%80%90DP%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/WQS_%E5%85%B1%E7%BA%BF-17071392712876.svg" srcset="/img/loading.gif" lazyload alt="WQS_共线">
<figcaption aria-hidden="true">WQS_共线</figcaption>
</figure>
<p><strong>如果一不注意就会 WA ！！！！！！！！！！！！QwQ</strong></p>
<p>当然实数二分就基本上没有这个烦恼，但是要注意处理好 eps 。</p>
<p>例题：WQS二分模板题第1题：邮局；WQS二分练习题：aliens</p>
<h5 id="注意-m-是否永远无法通过二分取到">(2) 注意 M
是否永远无法通过二分取到</h5>
<p>如果 $t &lt; M <sub>or</sub>M&lt;t $ 成立，则 <span class="math inline">\(M\)</span> 对应的 <span class="math inline">\(F(N,M)\)</span> 100%和二分边界的 <span class="math inline">\(F(N,t)\)</span> 共线，如果你的 <span class="math inline">\(f(N,M)\)</span>
计算放在二分循环内，将要特别考虑此种情况。</p>
<p>具体见练习题：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1484">P1484
种树</a>
的这行代码：<code>if (ans == -1) ans = val + k * mid;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ll l = <span class="hljs-number">0</span>, r = *<span class="hljs-built_in">max_element</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>), mid, val, cnt, ans = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>    mid = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">tie</span>(val, cnt) = <span class="hljs-built_in">check</span>(mid, ans);<br>    <span class="hljs-keyword">if</span> (cnt &gt;= k) l = mid + <span class="hljs-number">1</span>, ans = val + k * mid;<br>    <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 因为 cnt 最大为树坑为非负数的个数，所以 cnt 可能恒小于 k</span><br><span class="hljs-keyword">if</span> (ans == <span class="hljs-number">-1</span>) ans = val + k * mid;<br></code></pre></td></tr></table></figure>
<h4 id="wqs二分的拓展">WQS二分的拓展</h4>
<h5 id="a.-多重wqs二分">A. 多重WQS二分</h5>
<p>如果同时对两个受限制的变量进行二分，则相当于在凸曲面上寻找最值，利用的是曲面的凸性。</p>
<p>可以拓展至对任意多个受限制的变量进行二分，只要你能证明关于每个变量的
<span class="math inline">\(f\)</span> 都有凸性。</p>
<p>我们首先将问题简化为每一个变量都不受限制的情况，得到此时的 <span class="math inline">\(f(i)\)</span> ，然后设计 <span class="math inline">\(F(x)\)</span>
。通过多层嵌套的二分搜索（每一层搜索一个变量的 <span class="math inline">\(k\)</span> 值）搜索结果。</p>
<p>例题：WQS二分模板题第2题：CF739E Gosha is hunting</p>
<h5 id="b.-对任意凸函数中受限制变量进行二分">B.
对任意凸函数中受限制变量进行二分</h5>
<p>是的，WQS二分不仅仅可用于一般的DP最优化问题。只要你的问题是最优化问题，含有受限制参数，函数关于受限制变量是凸函数，就可以二分这个额外权重
<span class="math inline">\(k\)</span>
来搜索答案。（和树、图等等结合）</p>
<p>例题：WQS二分模板题第3题：P2619 [国家集训队] Tree I</p>
<h5 id="c.-对非凸函数进行wqs二分">C. 对非凸函数进行WQS二分</h5>
<p>以下内容仅仅为个人猜想，正确性未经过证明。</p>
<mydetails>
<summary>
<summary-title>Conjecture</summary-title><summary-subtitle>对非凸函数使用WQS二分的猜想</summary-subtitle>
</summary>
<p>设状态转移方程为： <span class="math inline">\(f(i,j)=optim\{g(i,j)+w(i)\}=optim\{G(i,j)\}\)</span>
。</p>
<p>则我们观察函数性质的域为： <span class="math inline">\(\begin{align}f(N,j)&amp;=optim\{g(N,j)+w(N)\}=optim\{G(N,j)\}\\
\Rightarrow f(x)&amp;=optim\{G(x)\}\end{align}\)</span> 。</p>
<p>如果当 <span class="math inline">\(f(i,j)\)</span> 关于 <span class="math inline">\(j\)</span>
不是凸函数，但<strong>定义域内只有一个极值点</strong>，即 <span class="math inline">\(f&#39;=0\)</span>
在定义域内有且仅有一个解，此时也是可以通过某种手段构造出极值点偏移的新函数的。但是就不是
<span class="math inline">\(kx\)</span> 了，可能是 <span class="math inline">\(k\ln x\)</span> 、<span class="math inline">\(k\sqrt{x}\)</span> 、<span class="math inline">\(\frac{k}{x}\)</span>
等等。具体如何选择合适的偏移项来构造，需要具体观察。</p>
<p><strong>例一</strong></p>
<p>下式中 <span class="math inline">\(f\)</span> 并不是凸函数，因为
<span class="math inline">\(f&#39;&#39;=\frac{2\ln x-3}{x^3}\)</span>
有一个零点。我们参考 <span class="math inline">\(f\)</span> 构造新的函数
<span class="math inline">\(F\)</span> ，并且使得 <span class="math inline">\(F&#39;=0\)</span>
在定义域内同样有且仅有一个解。</p>
<p><span class="math display">\[
\begin{align}
f(N,x)&amp;=f(x)=\frac{\ln(x)}{x},~f&#39;(x)=\frac{1-\ln x}{x^2}
\\F(N,x)&amp;=f(N,x)+\frac{k}{x}, ~~F&#39;(x)=\frac{1-\ln x-k}{x^2}
\end{align}
\]</span></p>
<p>易知 <span class="math inline">\(f\)</span> 有且仅有一个极值点，即
<span class="math inline">\(\ln x =1\)</span> 的时候。同时可知 <span class="math inline">\(F\)</span> 也是有且仅有一个极值点，即 <span class="math inline">\(\ln x =1-k\)</span>
的时候。因此可以使用WQS二分</p>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E3%80%90DP%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/WQS%20%E9%9D%9E%E5%87%B8%E5%87%BD%E6%95%B0-17071392712877.gif" srcset="/img/loading.gif" lazyload alt="WQS 非凸函数">
<figcaption aria-hidden="true">WQS 非凸函数</figcaption>
</figure>
<p>可见此方法可能在特定情境下有作用。</p>
<p><strong>例二</strong></p>
<p>下面 <span class="math inline">\(f(x)\)</span>
不是凸函数，考虑将其取倒数，则转变为二次函数。以此构造 <span class="math inline">\(F(x)\)</span> 。</p>
<p><span class="math display">\[
f(N,x)=f(x)=\frac{1}{x^2+1}\\
F(N,x)=F(x)=-\frac{1}{f(x)}+kx=x^2+kx+1
\]</span></p>
<p>则此时 <span class="math inline">\(f(x)=\frac{1}{kx-F(x)}\)</span>
。由 <span class="math inline">\(F(N, x=不限制)\)</span> 获得 <span class="math inline">\(f(N,x)\)</span> 的过程如下图所示：</p>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E3%80%90DP%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/WQS%E4%BA%8C%E5%88%86%E9%9D%9E%E5%87%B8%E5%87%BD%E6%95%B0%E7%8C%9C%E6%83%B3%20%E4%BE%8B2-17071392712878.gif" srcset="/img/loading.gif" lazyload alt="WQS二分非凸函数猜想 例2">
<figcaption aria-hidden="true">WQS二分非凸函数猜想 例2</figcaption>
</figure>
<p><strong>后记</strong></p>
<p>以上均为连续函数，对于离散函数，比较难判断它的性质，所以感觉这个方法也没什么用。仅仅作为WQS的深入思考。也许最优化理论里面有这些研究吧。等以后学了最优化回来看看。ψ(｀∇´)ψ</p>
<blockquote>
<p>要是我出WQS的题，就拿这个性质搞搞，嘻嘻~</p>
</blockquote>
<p></p></mydetails><p></p>
<hr>
<p>以上就是<strong>WQS二分</strong>的详细过程与证明。</p>
<p>国内一般认为该算法最早由王钦石在2012年的国家集训队论文提及，故称为WQS二分。国外称为
Aliens' Trick ，源自2016年 IOI 赛题 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5896">aliens</a>
的WQS二分解法。</p>
<h3 id="wqs二分模板题">WQS二分模板题</h3>
<h4 id="p4767-ioi2000-邮局">1. <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4767">P4767 [IOI2000]
邮局</a></h4>
<p><strong>题目描述</strong></p>
<p>高速公路旁边有一些村庄。高速公路表示为整数轴，每个村庄的位置用单个整数坐标标识。没有两个在同样地方的村庄。两个位置之间的距离是其整数坐标差的绝对值。</p>
<p>邮局将建在一些，但不一定是所有的村庄中。为了建立邮局，应选择他们建造的位置，使每个村庄与其最近的邮局之间的距离总和最小。</p>
<p>你要编写一个程序，已知村庄的位置和邮局的数量，计算每个村庄和最近的邮局之间所有距离的最小可能的总和。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含两个整数：第一个是村庄 <span class="math inline">\(V\)</span> 的数量，第二个是邮局的数量 <span class="math inline">\(P\)</span>。</p>
<p>第二行包含 <span class="math inline">\(V\)</span>
个整数。这些整数是村庄的位置。</p>
<p><strong>输出格式</strong></p>
<p>第一行包含一个整数<span class="math inline">\(S\)</span>，它是每个村庄与其最近的邮局之间的所有距离的总和。</p>
<p><strong>提示</strong></p>
<p>对于 <span class="math inline">\(40\%\)</span> 的数据，<span class="math inline">\(V \leq 300\)</span>。</p>
<p>对于 <span class="math inline">\(100\%\)</span> 的数据，<span class="math inline">\(1 \leq P \leq 300\)</span>，<span class="math inline">\(P \leq V \leq 3000\)</span>，$1 $ 村庄位置 <span class="math inline">\(\leq 10000\)</span>。</p>
<h5 id="wqs解题思路">WQS解题思路</h5>
<p>参考博客：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ydtz/p/16536706.html">【ydtz】奇淫技巧——wqs二分</a></p>
<blockquote>
<p>在分布在一条直线上的 <span class="math inline">\(n\)</span>
个村庄中选 <span class="math inline">\(k\)</span>
个建立邮局，求所有村庄到达其最近邮局的最小距离之和。<span class="math inline">\(n\le 3000,k\le 300\)</span>.</p>
</blockquote>
<p>这是一道四边形不等式优化 dp
的题目，但是四边形不等式好麻烦，我们不想用它 &gt;_&lt;</p>
<p>暴力的 dp 会怎么做它呢？我们通常会设 <span class="math inline">\(dp_{i,j}\)</span> 表示前 i 个村庄放 j
个邮局时的最小距离距离之和，于是有</p>
<p><span class="math display">\[
dp_{i,j}=\min(dp_{p,j-1}+w(p+1,i))\ ,\ (0\le p &lt;i)
\]</span></p>
<p>其中 <span class="math inline">\(w(i,j)\)</span> 表示的是在区间 <span class="math inline">\([i,j]\)</span>
中建立邮局，且该区间内的村庄与该邮局的距离之和。运用一些中位数的知识，显然邮局应该建立在该区间最中间的村庄内。</p>
<p>这样看来 dp 转移是 <span class="math inline">\(O(n^2k)\)</span>
的，计算 <span class="math inline">\(w(i,j)\)</span> 是 <span class="math inline">\(O(n)\)</span> 的，总复杂度到达了恐怖的 <span class="math inline">\(O(n^3k)\)</span>。</p>
<p>考虑继续优化，我们发现 <span class="math inline">\(w(i,j)\)</span>
是可以通过预处理提前求出的，由于一个区间向左右同时扩展一格时中位数不变，所以有递推式：</p>
<p><span class="math display">\[
w(i,i)=w(i+1,i)=0\\
w(i,j)=w(i+1,j-1)+a_j-a_i\ ,\ i\le j-1
\]</span></p>
<p>所以我们可以在 <span class="math inline">\(O(n^2)\)</span>
的复杂度内将 <span class="math inline">\(w(i,j)\)</span> 预处理出来，dp
的时间复杂度就优化到了 <span class="math inline">\(O(n^2k)\)</span>
。</p>
<p>但是仍然过不去。<del>考虑继续用四边形不等式优化</del>
拒绝四边形不等式！</p>
<p>我们发现其实 <span class="math inline">\(n^2\)</span>
完全是能过的，只要我们能将 <span class="math inline">\(k\)</span> 优化到
<span class="math inline">\(\log n\)</span>，他也是能过的。</p>
<p>但是单纯的 dp 显然无法做到，因为选择 <span class="math inline">\(k\)</span>
个物品这个条件所增加的状态数就足以支撑起 <span class="math inline">\(O(k)\)</span> 的时间复杂度。</p>
<p>这时就需要用我们的奇淫技巧——<strong>wqs 二分</strong>。</p>
<p>依旧设 <span class="math inline">\(f(i)\)</span> 为设立 <span class="math inline">\(i\)</span>
个邮局时的最小距离之和，则有两个性质：</p>
<ol type="1">
<li><p><span class="math inline">\(f(i)&lt;f(i−1)\)</span></p></li>
<li><p><span class="math inline">\(f(i)−f(i−1)≤f(i+1)−f(i)\)</span></p></li>
</ol>
<p>第一条十分显然，每增加一个邮局后的答案显然是不劣，主要看第二条。</p>
<p>第二条其实也很容易想到——每一个邮局造成影响的村庄都一定是一段区间，若后一个邮局的贡献会比前一个优，则前面显然可以先选择后一个邮局的位置建立邮局而非前一个邮局的位置，故贪心的讲，越靠前设立的邮局贡献一定越大。</p>
<p>通过这两条性质，我们可以很容易地推断出 <span class="math inline">\(f(i)\)</span>
的函数图像是一个下凸壳，于是就可以通过 wqs
二分将邮局个数的限制去掉，再跑 <span class="math inline">\(O(n^2)\)</span> dp 即可，时间复杂度 <span class="math inline">\(O(n^2 \log |V|)\)</span>，<span class="math inline">\(|V|\)</span> 是二分的值域。</p>
<p><strong>解题代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_V = <span class="hljs-number">3007</span>, MAX_P = <span class="hljs-number">307</span>;<br><span class="hljs-type">int</span> V, P;<br><span class="hljs-type">int</span> a[MAX_V], asum[MAX_V];  <span class="hljs-comment">// a[i] 表示村庄 i 的位置，asum[i] 表示前缀和（前 i 个村庄的位置和）</span><br><span class="hljs-comment">// 用前缀和 O(1) 计算 w(i,j)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">W</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>    <span class="hljs-type">int</span> mid = (i + j) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> (asum[j] - asum[mid]) - (asum[mid] - asum[i - <span class="hljs-number">1</span>] - a[mid] * ((i + j + <span class="hljs-number">1</span>) &amp; <span class="hljs-number">1</span>));<br>&#125;<br><span class="hljs-comment">// NOTE 这里可以用决策单调性二分队列优化为 O(nlogn)</span><br><span class="hljs-comment">// F(i) = min(F(j)+W(j+1,i)+k)</span><br><span class="hljs-comment">// 普通做法：check一次是O(n^2)，这里规定相同的消耗下，尽可能多建邮局</span><br><span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(F, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(F));<br>    F[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= V; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>, tmp; j &lt; i; j++) &#123;  <span class="hljs-comment">// 注意j可以也必须从0开始</span><br>            tmp = F[j] + <span class="hljs-built_in">W</span>(j + <span class="hljs-number">1</span>, i) + k;<br>            <span class="hljs-keyword">if</span> (tmp &lt;= F[i]) &#123;<br>                <span class="hljs-comment">// 尽可能少建邮局</span><br>                <span class="hljs-keyword">if</span> (tmp == F[i]) cnt[i] = <span class="hljs-built_in">min</span>(cnt[i], cnt[j] + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">else</span> cnt[i] = cnt[j] + <span class="hljs-number">1</span>;<br>                F[i] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;F[V], cnt[V]&#125;;<br>&#125;<br><span class="hljs-comment">// WQS二分查找：共查找 log2(n)=log2(3e7)=25 次</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">3000</span> * <span class="hljs-number">10000</span>, mid, ans;<br>    <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>        mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">auto</span> [Fx, cnt] = <span class="hljs-built_in">check</span>(mid);<br>        <span class="hljs-keyword">if</span> (cnt &gt; P) &#123;<br>            l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// [Fx, cnt] 是第一个 &gt;= P 的位置</span><br>            ans = F[V] - mid * P;   <span class="hljs-comment">// ans 和它共线</span><br>            r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; V &gt;&gt; P;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= V; i++) cin &gt;&gt; a[i];<br>    <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + V + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= V; i++) asum[i] = asum[i - <span class="hljs-number">1</span>] + a[i];<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>左边是尽可能少建邮局，右边是尽可能多建邮局，它们的二分搜索和 <span class="math inline">\(F\)</span> 计算是不同的！</p>
<p>注意整数二分的时候，答案的计算一定是在二分循环里面的，因为考虑到共线的情况，如果要算的点在共线的线段中间，我们整数二分搜索是肯定搜不到的，必须通过端点来计算！（端点选哪一个根据你
<span class="math inline">\(F\)</span> 选择的贪心策略）</p>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E3%80%90DP%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-02-01%20015608%20-%20%E5%89%AF%E6%9C%AC-17071392712879.png" srcset="/img/loading.gif" lazyload alt="代码差异">
<figcaption aria-hidden="true">代码差异</figcaption>
</figure>
<p>两种都能成功AC。但你要是搞错了一步就是一片的WA了！！！！虽然有的时候也能因为共线而AC。(～￣▽￣)～</p>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E3%80%90DP%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/image-20240201020150336-170713927128710.png" srcset="/img/loading.gif" lazyload alt="两种方式都可AC">
<figcaption aria-hidden="true">两种方式都可AC</figcaption>
</figure>
<h4 id="cf739e-gosha-is-hunting">2. <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF739E">CF739E Gosha is
hunting</a></h4>
<p><strong>题目描述</strong></p>
<p>你要抓神奇宝贝！ 现在一共有 <span class="math inline">\(n\)</span>
只神奇宝贝（ <span class="math inline">\(n \le 10^5\)</span> ）。你有
<span class="math inline">\(a\)</span> 个『宝贝球』和 <span class="math inline">\(b\)</span> 个『超级球』，其抓到第 <span class="math inline">\(i\)</span> 只神奇宝贝的概率分别是 <span class="math inline">\(p_i\)</span> 和 <span class="math inline">\(q_i\)</span>
，每种球不能在同一只神奇宝贝上使用多次。求最优策略下，抓到神奇宝贝的总个数期望最大值，保留五位小数。</p>
<h5 id="wqs解题思路-1">WQS解题思路</h5>
<p>这道题很好地指出了<strong>多重WQS二分</strong>是如何操作的。</p>
<p>设 <span class="math inline">\(f(i,j,k)\)</span> 为前 <span class="math inline">\(i\)</span> 个神奇宝贝中，用了 <span class="math inline">\(j\)</span> 个宝贝球和 <span class="math inline">\(k\)</span> 个超级球的最大期望值。</p>
<p><span class="math display">\[
\begin{align}
f(i,j,k)=max\{&amp;f(i-1,j,k),\\&amp;f(i-1,j-1,k)+p(i),\\&amp;f(i-1,j,k-1)+q(i),\\&amp;f(i-1,j-1,k-1)+1-(1-p(i))(1-q(i))\}
\end{align}
\]</span></p>
<p>去除限制，问题简化为：n
只神奇宝贝，<strong>任意使用宝贝球和超级球</strong></p>
<p>设 <span class="math inline">\(f(i)\)</span> 为前 <span class="math inline">\(i\)</span>
只神奇宝贝中，按照规则任意使用不限量宝贝球和超级球，抓到神奇宝贝的总个数期望最大值。</p>
<ol type="1">
<li>第 i 只不抓： <span class="math inline">\(f(i)=f(i-1)\)</span></li>
<li>第 i 只使用宝贝球： <span class="math inline">\(f(i)=f(i-1)+p(i)\)</span></li>
<li>第 i 只使用超级球： <span class="math inline">\(f(i)=f(i-1)+q(i)\)</span></li>
<li>第 i 只使用宝贝球和超级球： <span class="math inline">\(f(i)=f(i-1)+p(i)+q(i)-p(i)q(i)\)</span></li>
</ol>
<p><span class="math display">\[
\begin{align}
f(i)=\max\{
&amp;f(i-1),\\
&amp;f(i-1)+p(i),\\
&amp;f(i-1)+q(i),\\
&amp;f(i-1)+p(i)+q(i)-p(i)q(i)
\}
\end{align}
\]</span></p>
<p>设 <span class="math inline">\(F(i)=f(i)-c_aj-c_bk\)</span>
，则：</p>
<p><span class="math display">\[
\begin{align}
F(i)=\max\{
&amp;F(i-1),\\
&amp;F(i-1)+p(i)-c_a,\\
&amp;F(i-1)+q(i)-c_b,\\
&amp;F(i-1)+p(i)+q(i)-p(i)q(i)-c_a-c_b
\}
\end{align}
\]</span></p>
<p><span class="math inline">\(c_a\)</span> 和 <span class="math inline">\(c_b\)</span> 由两个二分搜索嵌套得到。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">2007</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-8</span>;<br><span class="hljs-type">int</span> n, a, b;<br><span class="hljs-type">double</span> p[MAXN], q[MAXN];<br><span class="hljs-type">double</span> F = -eps;<br><span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> ca, <span class="hljs-type">double</span> cb)</span> </span>&#123;<br>    <span class="hljs-type">double</span> prevF = <span class="hljs-number">0</span>, selnul, sela, selb, selab;<br>    <span class="hljs-type">int</span> prevCnta = <span class="hljs-number">0</span>, prevCntb = <span class="hljs-number">0</span>, cnta, cntb;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        sela   = prevF + p[i] - ca;<br>        selb   = prevF + q[i] - cb;<br>        selab  = prevF + p[i] + q[i] - p[i] * q[i] - ca - cb;<br>        F = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(prevF, sela), <span class="hljs-built_in">max</span>(selb, selab));<br>        <span class="hljs-keyword">if</span> (F - selab &lt; eps) cnta = prevCnta + <span class="hljs-number">1</span>, cntb = prevCntb + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (F - selb &lt; eps) cnta = prevCnta, cntb = prevCntb + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (F - sela &lt; eps) cnta = prevCnta + <span class="hljs-number">1</span>, cntb = prevCntb;<br>        <span class="hljs-keyword">else</span> cnta = prevCnta, cntb = prevCntb;<br>        prevF = F, prevCnta = cnta, prevCntb = cntb;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(cnta, cntb);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">double</span> la = <span class="hljs-number">0</span>, ra = <span class="hljs-number">1</span>, mida, lb, rb, midb;<br>    pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>    <span class="hljs-keyword">while</span> (la + eps &lt; ra) &#123;<br>        mida = (la + ra) / <span class="hljs-number">2</span>;<br>        lb = <span class="hljs-number">0</span>, rb = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (lb + eps &lt; rb) &#123;<br>            midb = (lb + rb) / <span class="hljs-number">2</span>;<br>            cnt = <span class="hljs-built_in">check</span>(mida, midb);<br>            <span class="hljs-keyword">if</span> (cnt.second &gt; b) lb = midb + eps;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt.second &lt; b) rb = midb;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cnt.first &gt; a) la = mida + eps;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt.first &lt; a) ra = mida;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 这里因为小数几乎不会共线，所以不考虑共线</span><br>    <span class="hljs-comment">// 如果是整数二分则万万不可草率地放在外面计算！！！</span><br>    cout &lt;&lt; F + mida * a + midb * b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; p[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; q[i];<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这道题很好地展示了多重WQS的代码，以及实数二分的WQS。思想和前一题邮局差不多。只要注意二分和F计算相匹配，可以轻松AC。</p>
<p>这里和上一题不同的是，答案的计算放在了二分循环外面，因为是实数二分，<strong>几乎不可能共线</strong>，所以最后二分出来的
<span class="math inline">\(k\)</span>
一定是等于限定值，可以直接使用。要注意二分出来的结果是哪个变量。</p>
<p>（WQS最容易出错的地方在于二分，因为二分本身写法多样，细节多，出错率高）</p>
<h4 id="p2619-国家集训队-tree-i">3. <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2619">P2619 [国家集训队] Tree
I</a></h4>
<p><strong>题目描述</strong></p>
<p>给你一个无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有
need 条白色边的生成树。</p>
<p>题目保证有解。</p>
<p><strong>输入格式</strong></p>
<p>第一行 V,E,need 分别表示点数，边数和需要的白色边数。</p>
<p>接下来 E 行，每行 s,t,c,col 表示这边的端点（点从 0
开始标号），边权，颜色（0 白色 1 黑色）。</p>
<p><strong>输出格式</strong></p>
<p>一行，表示所求生成树的边权和。</p>
<p><strong>提示</strong></p>
<p>对于 5% 的数据，V≤10。 对于另 15% 的数据，V≤15。对于 100%
的数据，V≤5×10<sup>4,E≤10</sup>5。</p>
<p>所有数据边权为 [1,100] 中的正整数。</p>
<h5 id="wqs解题思路-2">WQS解题思路</h5>
<p><strong>WQS</strong></p>
<p>二分每次选择白色边的额外权重 k，然后求最小生成树的权重。</p>
<p><strong>Kruskal</strong></p>
<ol type="1">
<li>将所有边按权重从小到大排序</li>
<li>依次选择边，如果边的两个端点不在同一个集合中，则将这条边加入最小生成树中</li>
<li>直到最小生成树中有 V-1 条边</li>
<li>返回树中白色边的数量</li>
</ol>
<p><strong>WQS + Kruskal</strong></p>
<ol type="1">
<li>白边和黑边分别存储，然后按照权重排序</li>
<li>二分每次选择白色边的额外权重 k</li>
<li>为每条白色边的权重加上 k</li>
<li>重新排序所有边（归并排序白边和黑边）</li>
<li>用 Kruskal 求最小生成树</li>
<li>返回树中白色边的数量</li>
<li>如果白色边的数量大于等于 need，则说明 k 太大，否则 k 太小</li>
<li>二分直到找到最小的 k</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> V_MAX = <span class="hljs-number">5e4</span> + <span class="hljs-number">10</span>, E_MAX = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123; <span class="hljs-type">int</span> s, t, c, col; &#125;;<br><span class="hljs-type">int</span> wcnt, bcnt;<br>edge W[E_MAX], B[E_MAX], G[E_MAX];<br><span class="hljs-type">int</span> V, E, need;<br><span class="hljs-type">int</span> par[V_MAX];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> par[x] == x ? x : par[x] = <span class="hljs-built_in">find</span>(par[x]); &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> wp = <span class="hljs-number">0</span>, bp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; E; i++) &#123;<br>        <span class="hljs-keyword">if</span> (wp &lt; wcnt &amp;&amp; bp &lt; bcnt) &#123;<br>            <span class="hljs-keyword">if</span> (W[wp].c + k &lt;= B[bp].c) G[i] = W[wp++], G[i].c += k;<br>            <span class="hljs-keyword">else</span> G[i] = B[bp++];<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wp &lt; wcnt) G[i] = W[wp++], G[i].c += k;<br>        <span class="hljs-keyword">else</span> G[i] = B[bp++];<br>    &#125;<br>&#125;<br><span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">kruskal</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> val = <span class="hljs-number">0</span>, selwcnt = <span class="hljs-number">0</span>, selcnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++) par[i] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; E; i++) &#123;<br>        <span class="hljs-keyword">if</span> (selcnt == V - <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-type">int</span> par_s = <span class="hljs-built_in">find</span>(G[i].s), <span class="hljs-type">par_t</span> = <span class="hljs-built_in">find</span>(G[i].t);<br>        <span class="hljs-keyword">if</span> (par_s == <span class="hljs-type">par_t</span>) <span class="hljs-keyword">continue</span>;<br>        par[par_s] = <span class="hljs-type">par_t</span>;<br>        val += G[i].c;<br>        selwcnt += (G[i].col == <span class="hljs-number">0</span>);<br>        selcnt++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;val, selwcnt&#125;;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">-100</span>, r = <span class="hljs-number">100</span>, mid, val, cnt, ans;<br>    <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>        mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">mergeSort</span>(mid);<br>        <span class="hljs-built_in">tie</span>(val, cnt) = <span class="hljs-built_in">kruskal</span>();<br>        <span class="hljs-keyword">if</span> (cnt &gt;= need) l = mid + <span class="hljs-number">1</span>, ans = val - mid * need;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>    cin &gt;&gt; V &gt;&gt; E &gt;&gt; need;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; E; i++) &#123;<br>        <span class="hljs-type">int</span> s, t, c, col;<br>        cin &gt;&gt; s &gt;&gt; t &gt;&gt; c &gt;&gt; col;<br>        <span class="hljs-keyword">if</span> (col) B[bcnt++] = &#123;s, t, c, col&#125;;<br>        <span class="hljs-keyword">else</span> W[wcnt++] = &#123;s, t, c, col&#125;;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(W, W + wcnt, [](edge a, edge b) &#123; <span class="hljs-keyword">return</span> a.c &lt; b.c; &#125;);<br>    <span class="hljs-built_in">sort</span>(B, B + bcnt, [](edge a, edge b) &#123; <span class="hljs-keyword">return</span> a.c &lt; b.c; &#125;);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="wqs二分练习题">WQS二分练习题</h3>
<h4 id="p1484-种树"><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1484">P1484 种树</a></h4>
<p><strong>题意概述</strong></p>
<p>数轴上有 n 个点，每个点有一个价值
a（可以为负），两个点相邻则只能选其中一个。至多选 k
个点，计算最大价值。</p>
<p><strong>WQS解题思路</strong></p>
<p>很简单，直接WQS干就完了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">300007</span>;<br>ll n, k;<br><span class="hljs-type">int</span> a[MAXN];<br><span class="hljs-function">pair&lt;ll, ll&gt; <span class="hljs-title">check</span><span class="hljs-params">(ll C, ll&amp; ans)</span> </span>&#123;<br>    ll yes = a[<span class="hljs-number">1</span>] - C, no = <span class="hljs-number">0</span>, yesCnt = <span class="hljs-number">1</span>, noCnt = <span class="hljs-number">0</span>;<br>    ll prev_yes, prev_no, prev_yesCnt, prev_noCnt;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        prev_yes = yes, prev_no = no, prev_yesCnt = yesCnt, prev_noCnt = noCnt;<br>        yes = prev_no + a[i] - C;<br>        yesCnt = prev_noCnt + <span class="hljs-number">1</span>;<br>        no = <span class="hljs-built_in">max</span>(prev_yes, prev_no);<br>        <span class="hljs-comment">// 选择种树最多的方案</span><br>        <span class="hljs-keyword">if</span> (prev_yes == prev_no) noCnt = <span class="hljs-built_in">max</span>(prev_yesCnt, prev_noCnt);<br>        <span class="hljs-keyword">else</span> noCnt = (prev_yes &gt; prev_no) ? prev_yesCnt : prev_noCnt;<br>    &#125;<br>    ll val = <span class="hljs-built_in">max</span>(yes, no), cnt;<br>    <span class="hljs-keyword">if</span> (yes == no) cnt = <span class="hljs-built_in">max</span>(yesCnt, noCnt);<br>    <span class="hljs-keyword">else</span> cnt = (yes &gt; no) ? yesCnt : noCnt;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(val, cnt);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cin &gt;&gt; a[i];<br>    ll l = <span class="hljs-number">0</span>, r = *<span class="hljs-built_in">max_element</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>), mid, val, cnt, ans = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>        mid = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">tie</span>(val, cnt) = <span class="hljs-built_in">check</span>(mid, ans);<br>        <span class="hljs-keyword">if</span> (cnt &gt;= k) l = mid + <span class="hljs-number">1</span>, ans = val + k * mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 因为 cnt 最大为树坑为非负数的个数，所以 cnt 可能恒小于 k</span><br>    <span class="hljs-keyword">if</span> (ans == <span class="hljs-number">-1</span>) ans = val + k * mid;<br>    cout &lt;&lt; ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="p5896-ioi2016-aliens"><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5896">P5896 [IOI2016]
aliens</a></h4>
<p><strong>题意概述</strong></p>
<p>m x m 方格中填有非负整数，其和为 n
。规定左上到右下为对角线，选择的正方形区域的对角线必须和这条对角线重合。在对角线上选择正方形区域，使得正方形能够覆盖所有不为
0 的方格，并要求被覆盖的方格数最小。现在限制最多只能选择 k
个正方形，求最小的被覆盖的方格数。</p>
<p><strong>WQS解题思路</strong></p>
<ol type="1">
<li>凸性。那必然拍的越多，每次降低的费用就越少。</li>
<li>将方格左下三角形按照对角线对称到右上，不影响结果。</li>
<li>将每个点的坐标视为线段区间，这根线段则是在对角线上的。作正方形区域，相当于取对角线上的一个线段区间。</li>
<li>排序线段。对线段按照左端点从小到大排序，相同则按照右端点降序。</li>
<li>删除被包含的线段。通过对比右端点（因为左右端点已有序）。</li>
<li>WQS二分每次拍照额外的费用 <span class="math inline">\(C\)</span>
，值域设置到题目极限状态 <span class="math inline">\([0,m^2]\)</span>
，否则被卡。</li>
<li>设 <span class="math inline">\(f(i)\)</span> 为前 i
个线段所拍到的最少方格数量，则 <span class="math inline">\(F(i) = f(i) +
C * 拍照次数\)</span> 。</li>
<li>$F(i) = F(j)+(r_i-l_{j+1}-1)^2-G(j)+C,G(j)= <span class="math display">\[\begin{align}\left\{\begin{aligned}&amp;
(r_j-l_{j+1}+1)^2,\quad r_j \ge l_{j+1} \\&amp; 0,\quad r_j &lt;
l_{j+1}\end{aligned}\right.\end{align}\]</span> $ 。 <span class="math inline">\(G(j)\)</span>
是新拍照区域和旧区域的重叠区域，根据是否重叠，减去重复计算的方格。</li>
<li>上面的式子平方项很眼熟，直接斜率优化+单调队列 <span class="math inline">\(O(n)\)</span> 解决。</li>
<li>最终时间复杂度为 <span class="math inline">\(O\left(n\log
(m^2)\right)= O(n\log m)\)</span> 。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 100007</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">seg</span> &#123;ll l, r;&#125; a[MAXN];<br>ll n, m, k;<br>ll q[MAXN], head = <span class="hljs-number">0</span>, tail = <span class="hljs-number">-1</span>;<br>ll F[MAXN], CNT[MAXN], C;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQ(x) ((x)*(x))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> X(j) (a[j+1].l)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> G(j) (a[j].r&gt;=a[j+1].l?SQ(a[j].r-a[j+1].l+1):0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Y(j) (F[j]+SQ(a[j+1].l)-G(j)+C)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> K(i) (2*(a[i].r+1))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> B(i) (F[i]-SQ(a[i].r+1))</span><br><span class="hljs-comment">// 使用 &lt;= 尽可能多拍照片</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> slope_le_k(p1,p2,k) ((Y(p1)-Y(p2))&lt;=(X(p1)-X(p2))*(k))  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> k1_le_k2(p1,p2,p3,p4) ((Y(p1)-Y(p2))*(X(p3)-X(p4))&lt;=(Y(p3)-Y(p4))*(X(p1)-X(p2)))</span><br><span class="hljs-comment">// 斜率优化</span><br><span class="hljs-function">pair&lt;ll, ll&gt; <span class="hljs-title">check</span><span class="hljs-params">()</span> </span>&#123;<br>    head = <span class="hljs-number">1</span>, tail = <span class="hljs-number">1</span>;<br>    q[tail] = <span class="hljs-number">0</span>, F[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, CNT[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">while</span> (head &lt; tail &amp;&amp; <span class="hljs-built_in">slope_le_k</span>(q[head+<span class="hljs-number">1</span>], q[head], <span class="hljs-built_in">K</span>(i))) head++;<br>        ll j = q[head];<br>        F[i] = F[j] + <span class="hljs-built_in">SQ</span>(a[i].r-a[j+<span class="hljs-number">1</span>].l+<span class="hljs-number">1</span>) - <span class="hljs-built_in">G</span>(j) + C;<br>        CNT[i] = CNT[j] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (head &lt; tail &amp;&amp; <span class="hljs-built_in">k1_le_k2</span>(q[tail], i, q[tail<span class="hljs-number">-1</span>], q[tail])) tail--;<br>        q[++tail] = i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(F[n], CNT[n]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    a[<span class="hljs-number">0</span>].l = <span class="hljs-number">-1</span>, a[<span class="hljs-number">0</span>].r = <span class="hljs-number">-1</span>;   <span class="hljs-comment">// 非常重要，否则一开始G(0)会出错</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; a[i].l &gt;&gt; a[i].r;<br>        <span class="hljs-keyword">if</span> (a[i].l &gt; a[i].r) <span class="hljs-built_in">swap</span>(a[i].l, a[i].r);<br>    &#125;;<br>    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>, a+n+<span class="hljs-number">1</span>, [](seg _a, seg _b)&#123;<span class="hljs-keyword">return</span> _a.l==_b.l?_a.r&gt;_b.r:_a.l&lt;_b.l;&#125;);<br><br>    <span class="hljs-comment">// 去掉被包含的线段</span><br>    ll wp = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, prev_r = a[<span class="hljs-number">1</span>].r; i &lt;= n; i++)<br>        <span class="hljs-keyword">if</span> (prev_r &lt; a[i].r) a[++wp] = a[i], prev_r = a[i].r;<br>    n = wp;<br><br>    <span class="hljs-comment">// WQS二分</span><br>    ll lt = <span class="hljs-number">0</span>, rt = <span class="hljs-number">1e12</span>, val, cnt, ans = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (k &gt; n) k = n;  <span class="hljs-comment">// 用了这个优化，就不需要下面的 if (ans == -1) 了</span><br>    <span class="hljs-keyword">while</span> (lt &lt;= rt) &#123;<br>        C = (lt + rt) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">tie</span>(val, cnt) = <span class="hljs-built_in">check</span>();<br>        <span class="hljs-comment">// 在多点共线的线段上，[val, cnt] 是最后一个 &gt;= k 的值</span><br>        <span class="hljs-keyword">if</span> (cnt &gt;= k) lt = C + <span class="hljs-number">1</span>, ans = val - k * C;  <span class="hljs-comment">// [val, k] 和 [val, cnt] 共线</span><br>        <span class="hljs-keyword">else</span> rt = C - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (cnt == k) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 非常必要的小优化</span><br>    &#125;<br>    <span class="hljs-comment">// 虽然是凸函数，但是单调不增，并且最终无论拍多少次，都会收敛到一个值。</span><br>    <span class="hljs-comment">// 所以当 k &gt; n 时，cnt 必然小于 k，而 k 会和 n 共线</span><br>    <span class="hljs-comment">// if (ans == -1) ans = val - k * C;  </span><br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>同样对比两种不同的二分方式和F计算：</p>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E3%80%90DP%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/aliens%E5%AF%B9%E6%AF%94-170713927128711.png" srcset="/img/loading.gif" lazyload alt="aliens对比">
<figcaption aria-hidden="true">aliens对比</figcaption>
</figure>
<p>两种都可成功AC：</p>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E3%80%90DP%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/image-20240203165559581-170713927128712.png" srcset="/img/loading.gif" lazyload alt="image-20240203165559581">
<figcaption aria-hidden="true">image-20240203165559581</figcaption>
</figure>
<h2 id="d1d-四边形不等式优化">5 (2D/1D) 四边形不等式优化</h2>
<h4 id="概念-3">概念</h4>
<p>这里的四边形不等式优化指的是<strong>区间决策单调性</strong>优化。</p>
<p>四边形不等式常用于优化 2D/1D 方程，意思是我们计算的 <span class="math inline">\(dp[i][j]\)</span> 的状态维度是 2 维的 <span class="math inline">\([i][j]\)</span> ，决策点的维度是 1 维的 <span class="math inline">\([k]\)</span> 。</p>
<p><strong>四边形不等式特征状态方程</strong>： <span class="math display">\[
\begin{align}
dp[i][j] &amp;= \min\{dp[i][k]+dp[k+1][j]+w[i][j]\},\quad k \in [i,j-1]
\\
&amp;=\min\{dp[i][k]+dp[k+1][j]\}+w[i][j]
\end{align}
\]</span></p>
<p><strong>四边形不等式</strong>：</p>
<p><span class="math display">\[
\begin{align}
w(a,c)+w(b,d)&amp;\le w(a,d) + w(b,c),\quad a\le b\le c\le d\\
或者~w(i,j)+w(i+1,j+1)&amp;\le w(i,j+1) + w(i+1,j),\quad i&lt;i+1\le j
&lt;j+1
\end{align}
\]</span></p>
<ul>
<li>速记：<strong>左中区间 + 右中区间 <span class="math inline">\(\le\)</span> 大区间 + 小区间</strong></li>
</ul>
<p><strong>单调性</strong>： <span class="math display">\[
对任意~a\le b\le c\le d,~有~w(b,c) \le w(a,d). \\
或者~w(i+1,j) \le w(i,j+1)
\]</span></p>
<ul>
<li>速记：<strong>小区间 <span class="math inline">\(\le\)</span>
大区间</strong>，类似于一维的单调递增</li>
</ul>
<p><strong>四边形不等式定理</strong>：如果 <span class="math inline">\(w(i,j)\)</span>
满足<strong>四边形不等式</strong>和<strong>单调性</strong>，则用DP计算
<span class="math inline">\(dp[][]\)</span> 的时间复杂度为 <span class="math inline">\(O(n^2)\)</span></p>
<p><strong>引理 1</strong>：如果 <span class="math inline">\(w(i,j)\)</span> 满足四边形不等式和单调性，则 <span class="math inline">\(dp[i][j] =
\min(dp[i][k]+dp[k+1][j]+w[i][j])\)</span>
<strong>也满足四边形不等式</strong>。</p>
<p><strong>引理 2</strong>：记 <span class="math inline">\(s[i][j]=k\)</span> 为 <span class="math inline">\(dp[i][j]\)</span> 取得最小值时的 <span class="math inline">\(k\)</span>，如果 <span class="math inline">\(dp[i][j]\)</span> 满足四边形不等式，则有：</p>
<p><span class="math display">\[
s[i][j-1]\le k \le s[i+1][j]
\]</span></p>
<ul>
<li>速记：<strong>左中区间 <span class="math inline">\(\le\)</span>
大区间 <span class="math inline">\(\le\)</span> 右中区间</strong></li>
</ul>
<hr>
<p><strong>反四边形不等式特征状态方程（min变为max）</strong>：</p>
<p><span class="math display">\[
\begin{align}
dp[i][j] &amp;= \max\{dp[i][k]+dp[k+1][j]+w[i][j]\},\quad k \in [i,j-1]
\\
&amp;=\max\{dp[i][k]+dp[k+1][j]\}+w[i][j]
\end{align}
\]</span></p>
<p><strong>反四边形不等式（<span class="math inline">\(\le\)</span> 变为
<span class="math inline">\(\ge\)</span>）</strong>：</p>
<p><span class="math display">\[
\begin{align}
w(a,c)+w(b,d)&amp;\ge w(a,d) + w(b,c),\quad a\le b\le c\le d\\
或者~w(i,j)+w(i+1,j+1)&amp;\ge w(i,j+1) + w(i+1,j),\quad i&lt;i+1\le j
&lt;j+1
\end{align}
\]</span></p>
<ul>
<li>速记：<strong>左中区间+右中区间 <span class="math inline">\(\ge\)</span> 大区间+小区间</strong></li>
</ul>
<p><strong>单调性（<span class="math inline">\(\le\)</span> 变为 <span class="math inline">\(\ge\)</span>）</strong>：</p>
<p><span class="math display">\[
对任意~a\le b\le c\le d,~有~w(b,c) \ge w(a,d).
\]</span></p>
<ul>
<li>速记：<strong>小区间 <span class="math inline">\(\ge\)</span>
大区间</strong>，类似于一维的单调递减</li>
</ul>
<p><strong>反四边形不等式定理</strong>：如果 <span class="math inline">\(w(i,j)\)</span>
满足<strong>反四边形不等式</strong>和<strong>单调性</strong>，则用DP计算
<span class="math inline">\(dp[][]\)</span> 的时间复杂度为 <span class="math inline">\(O(n^2)\)</span></p>
<p><strong>引理 3</strong>：如果 <span class="math inline">\(w(i,j)\)</span> 满足反四边形不等式和单调性，则
<span class="math inline">\(dp[i][j] =
\max(dp[i][k]+dp[k+1][j]+w[i][j])\)</span>
<strong>也满足反四边形不等式</strong>。</p>
<p><strong>引理 4</strong>：记 <span class="math inline">\(s[i][j]=k\)</span> 为 <span class="math inline">\(dp[i][j]\)</span> 取得最大值时的 <span class="math inline">\(k\)</span>，如果 <span class="math inline">\(dp[i][j]\)</span>
满足反四边形不等式，则有（和前面的相同）：</p>
<p><span class="math display">\[
s[i][j-1]\le k \le s[i+1][j]
\]</span></p>
<ul>
<li>速记：<strong>左中区间 <span class="math inline">\(\le\)</span>
大区间 <span class="math inline">\(\le\)</span> 右中区间</strong></li>
</ul>
<hr>
<h4 id="四边形不等式优化模板代码">四边形不等式优化模板代码</h4>
<p>石子合并问题</p>
<p><span class="math inline">\(\texttt{Description}\)</span></p>
<p>有 n
堆石子排成一排，每堆石子有一定的数量。每次可以将两堆相邻的石子堆合并，合并后的石子堆的数量为两堆石子堆的数量之和。合并的费用为两堆石子堆的数量之和。经过n-1次合并后，所有的石子堆都被合并成了一堆，求出总费用的最小值。</p>
<p><span class="math inline">\(\texttt{Input}\)</span></p>
<p>第一行：n，表示石子堆数目； 第二行：n个数，表示每堆石子的数量</p>
<p><span class="math inline">\(\texttt{Output}\)</span></p>
<p>输出总费用的最小值 (附加：求最大值)</p>
<p><span class="math inline">\(\texttt{Hint}\)</span></p>
<blockquote>
<p>合并过程：(2,4,5) -&gt; (6,5) -&gt; (11) 总费用为17</p>
</blockquote>
<p><strong>题解</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1002</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> w[N];      <span class="hljs-comment">// 前缀和维护[i,j]中的所有石子数量</span><br><span class="hljs-type">int</span> dp[N][N];  <span class="hljs-comment">// dp[i][j] 表示合并[i,j]中石子的最优值</span><br><span class="hljs-type">int</span> s[N][N];   <span class="hljs-comment">// s[i][j] 表示最佳分割点</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sum(i, j) w[j] - w[i - 1]</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, tmp; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; tmp;<br>        w[i] = w[i - <span class="hljs-number">1</span>] + tmp;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 求最小值</span><br>    <span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        dp[i][i] = <span class="hljs-number">0</span>;<br>        s[i][i] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; len++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = i + len - <span class="hljs-number">1</span>; j &lt;= n; i++, j++) &#123;<br>            <span class="hljs-comment">// 此处用四边形不等式优化，因为sum[i,j]满足四边形恒等式和单调递增（单调递增只是比喻的说法）</span><br>            <span class="hljs-comment">// 原本的 for (int k = i; k &lt; j; k++) 优化为下面的</span><br>            <span class="hljs-comment">// 注意右侧区间端点是 &lt;=</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = s[i][j - <span class="hljs-number">1</span>]; k &lt;= s[i + <span class="hljs-number">1</span>][j]; k++) &#123;<br>                <span class="hljs-keyword">if</span> (dp[i][j] &gt; dp[i][k] + dp[k + <span class="hljs-number">1</span>][j] + <span class="hljs-built_in">sum</span>(i, j)) &#123;<br>                    dp[i][j] = dp[i][k] + dp[k + <span class="hljs-number">1</span>][j] + <span class="hljs-built_in">sum</span>(i, j);<br>                    s[i][j] = k;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[<span class="hljs-number">1</span>][n] &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 下面求最大值，这个要改一下初始化</span><br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        dp[i][i] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; len++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = i + len - <span class="hljs-number">1</span>; j &lt;= n; i++, j++) &#123;<br>            <span class="hljs-comment">// 此处不可以用反四边形不等式优化，因为sum[i,j]不满足单调递减（单调递减只是比喻的说法）</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i; k &lt; j; k++) &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i][k] + dp[k + <span class="hljs-number">1</span>][j] + <span class="hljs-built_in">sum</span>(i, j));<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[<span class="hljs-number">1</span>][n] &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于 <span class="math inline">\(f(i)=min\{g(j)+w(i,j)\}\)</span>
此类方程，通常称为1D/1D动态规划，意为状态是1D的，决策点也是1D的。
对于该方程，目前我所知道的有4种特殊情况：</p>
<ol type="1">
<li><p><span class="math inline">\(w(i,j)= p*a(i) + q*b(j) + C\)</span>
：二元一次多项式形式</p>
<p><span class="math display">\[
\begin{align}
f(i)&amp;=min\{g(j)+p*a(i) + q*b(j) + C\}\\
&amp;=min\{G(j)\}+W(i)
\end{align}
\]</span></p>
<p>通过单调队列处理 <span class="math inline">\(G(j)\)</span> 实现 <span class="math inline">\(O(n)\)</span> 时间复杂度。</p></li>
<li><p><span class="math inline">\(w(i,j)=p*a(i)^2 + q*b(j)^2 +
r*a(i)*b(j) + C, r*a(i)与b(j)的单调性相反\)</span>
：二元二次多项式形式</p>
<p><span class="math display">\[
\begin{align}
f(i)&amp;=min\{g(j)+p*a(i)^2 + q*b(j)^2 + r*a(i)*b(j) + C\} \\
(f(i)-p*a(i)^2)&amp;=(g(j)+q*b(j)^2)+(r*a(i)*b(j))+C\\
(g(j)+q*b(j)^2)&amp;=(f(i)-p*a(i)^2-C)-(r*a(i)*b(j))\\
Y(j)&amp;=B(i)+K(i)X(j)\\
Y(j-1)&amp;=B(i)+K(i)X(j-1)\\
K(i)&amp;=\frac{Y(j)-Y(j-1)}{X(j)-X(j-1)}\\
F(i)&amp;=\min\{G(j)\} + W(i),W(i)=0
\end{align}
\]</span></p>
<p>通过单调队列维护 <span class="math inline">\(G(j)=\frac{Y(j)-Y(j-1)}{X(j)-X(j-1)}\)</span> 实现
<span class="math inline">\(O(n)\)</span> 时间复杂度。</p></li>
<li><p><span class="math inline">\(w(i,j)+w(i+1,j+1) \le
w(i,j+1)+w(i+1,j),i\le j\)</span> ：四边形不等式形式</p>
<p><span class="math inline">\(f(i)\)</span> 满足决策单调性：</p>
<p><span class="math display">\[
\begin{align}
k(i-1) \le k(i) \le k(i+1)
\end{align}
\]</span></p>
<p>使用单调队列+二分搜索优化，时间复杂度为 <span class="math inline">\(O(n\log n)\)</span> 。</p></li>
<li><p><span class="math inline">\(w(i,j)+w(i+1,j+1) \le
w(i,j+1)+w(i+1,j),w(i+1,j)\le w(i,j+1),i\le j\)</span>
：四边形不等式+单调性形式</p>
<p><span class="math inline">\(f(i)\)</span> 满足区间决策单调性：</p>
<p><span class="math display">\[
\begin{align}
k(i,j-1) \le k(i,j) \le k(i+1,j)
\end{align}
\]</span></p>
<p>使用 <span class="math inline">\(???\)</span> 优化，时间复杂度为
<span class="math inline">\(O(???)\)</span> 。</p></li>
</ol>
<h2 id="矩阵乘法优化">6 矩阵乘法优化</h2>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95/" class="category-chain-item">算法</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="category-chain-item">动态规划</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Algorithm-%E7%AE%97%E6%B3%95/">#Algorithm 算法</a>
      
        <a href="/tags/DP/">#DP</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【算法】【DP】DP优化总结</div>
      <div>https://qalxry.github.io/2024/01/20/【算法】【DP】DP优化总结/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>しずり雪</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年1月20日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2024年2月5日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                    <i class="iconfont icon-nc"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/01/27/%E3%80%90Hexo%E3%80%91%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E8%AE%B0%E5%BD%95-2024%E5%B9%B41%E6%9C%8826%E6%97%A5/" title="【Hexo】网站建设记录-2024年1月26日">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【Hexo】网站建设记录-2024年1月26日</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/01/17/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E3%80%90%E7%8A%B6%E5%8E%8BDP%E3%80%91%E6%9C%80%E7%9F%AD-Hamilton-%E8%B7%AF%E5%BE%84%E4%B8%AD%E8%A2%AB%E5%BF%BD%E8%A7%86%E7%9A%84%E7%8E%84%E5%A6%99%E4%B9%8B%E5%A4%84/" title="【算法】【状压DP】最短 Hamilton 路径中被忽视的玄妙之处">
                        <span class="hidden-mobile">【算法】【状压DP】最短 Hamilton 路径中被忽视的玄妙之处</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="right-sidebar side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
      <a href='https://hexo.io' target='_blank' rel='nofollow noopener'><span>Hexo</span></a> 
<i class='iconfont icon-love'></i>
<a href='https://github.com/fluid-dev/hexo-theme-fluid' target='_blank' rel='nofollow noopener'><span>Fluid</span></a>
<div style='font-size: 0.85rem'>
<span id='timeDate'>载入天数...</span>
<span id='times'>载入时分秒...</span>
<script src='/js/duration.js'></script>
</div>

    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              },
              lazyAlwaysTypeset: (function() {
                // 检查页面上是否存在 'mydetails' 元素
                if (!document.querySelector('mydetails')) {
                  return null; // 如果不存在，返回 null
                } else {
                  return ['mydetails']; // 如果存在，返回包含 'mydetails' 的数组
                }
                // 如果你直接给一个列表，那么如果页面上不存在这个元素，MathJax 将会崩溃
              })(),
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="/js/d3.v7.min.js"></script>
<script src="/js/custom/mydetails.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
