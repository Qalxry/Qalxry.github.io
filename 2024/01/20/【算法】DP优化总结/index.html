

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head><!-- hexo injector head_begin start --><script src="/js/custom/auto_generate/theme_config.js" defer></script><!-- hexo injector head_begin end -->
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.jpg">
  <link rel="icon" href="/img/fluid.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#bbbbbb">
  <meta name="author" content="しずり雪">
  <meta name="keywords" content="">
  
    <meta name="description" content="DP优化总结   0 基本概念  1D&#x2F;1D 方程 2D&#x2F;1D 方程  1 (1D&#x2F;1D) 单调队列优化  概念 (1) \(ds[j]\) 与 \(i\) 无关：单调队列 (2) \(ds[j]\) 与 \(i\) 有关：二分单调栈 单调队列优化模板题  2 (1D&#x2F;1D) 斜率&#x2F;凸壳优化  概念 (1) \(k,x\) 同单调：单调队列 (">
<meta property="og:type" content="article">
<meta property="og:title" content="【算法】DP优化总结">
<meta property="og:url" content="https://qalxry.github.io/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="しずり雪 の Blog">
<meta property="og:description" content="DP优化总结   0 基本概念  1D&#x2F;1D 方程 2D&#x2F;1D 方程  1 (1D&#x2F;1D) 单调队列优化  概念 (1) \(ds[j]\) 与 \(i\) 无关：单调队列 (2) \(ds[j]\) 与 \(i\) 有关：二分单调栈 单调队列优化模板题  2 (1D&#x2F;1D) 斜率&#x2F;凸壳优化  概念 (1) \(k,x\) 同单调：单调队列 (">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://qalxry.github.io/img/piclib/ve04_b.jpg">
<meta property="article:published_time" content="2024-01-20T12:55:20.000Z">
<meta property="article:modified_time" content="2024-04-13T13:01:49.167Z">
<meta property="article:author" content="しずり雪">
<meta property="article:tag" content="DP">
<meta property="article:tag" content="Algorithm 算法">
<meta property="article:tag" content="DP优化">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://qalxry.github.io/img/piclib/ve04_b.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>【算法】DP优化总结 - しずり雪 の Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom/mydetails.css">
<link rel="stylesheet" href="/css/custom/fonts.css">
<link rel="stylesheet" href="/css/custom/toc.css">
<link rel="stylesheet" href="/css/custom/base.css">
<link rel="stylesheet" href="/css/custom/icons.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"qalxry.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
            <script>
            document.subthemes = {
                default: "none",
                list: [{"name":"none","path":"/"},{"name":"classic","path":"/subthemes/classic/"},{"name":"modern","path":"/subthemes/modern/"}]
            };
            </script>

            <script src="/subthemes/subthemes.js" defer></script>
            <style>
                #theme-toggle-btn .nav-link {
                    display: block;
                    color: var(--navbar-text-color);
                    transition: color 0.2s ease-in-out, background-color 0.2s ease-in-out;
                }
                #theme-toggle-btn .nav-link svg {
                    transition: fill 0.2s ease-in-out;
                    fill: var(--navbar-text-color);
                }
                #theme-toggle-btn .nav-link:hover svg {
                    fill: var(--link-hover-color);
                }
            </style>
            <link rel="stylesheet" href="/subthemes/classic/css/main.css">
<link rel="stylesheet" href="/subthemes/modern/css/main.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


<body><!-- hexo injector body_begin start -->
        <script>
        console.log('[Extend Features] running...');
        document.extend_features = {"enable":false,"code_font":{"enable":false,"font_family":"SFMono-Regular,Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace","font_weight":400},"fixed_background":{"enable":false,"mask":{"enable":true,"list":[{"selector":"#web_bg","enable":true,"style":"background-color: rgba(0, 0, 0, 0.3);  border-radius: 1rem;"},{"selector":"#board","enable":true,"style":"background-color: rgba(0, 0, 0, 0);    border-radius: 1rem;"},{"selector":"#toc","enable":true,"style":"background-color: rgba(0, 0, 0, 0.15); border-radius: 1rem;"}]}}};
        </script>
        <script src="/extend_features/extend_features.js"></script>
        <!-- hexo injector body_begin end -->
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>しずり雪 の Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/2023/09/09/%E3%82%A2%E3%83%8B%E3%83%A1%E3%81%AE%E6%97%85%E3%80%85/">
                <i class="iconfont icon-timeline-fill"></i>
                <span>アニメ</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/2024/02/26/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0%E4%B8%8E%E6%9C%AA%E6%9D%A5%E8%AE%A1%E5%88%92/">
                <i class="iconfont icon-notebook"></i>
                <span>日记</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/2025/07/11/Ideas/">
                <i class="iconfont icon-lightbulb"></i>
                <span>Ideas</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/piclib/ve04_b.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="【算法】DP优化总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-01-20 20:55" pubdate>
          2024年1月20日 晚上 20:55
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          49k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          206 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="left-sidebar side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">【算法】DP优化总结</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2024年4月13日 晚上 21:01
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="dp优化总结">DP优化总结</h1>
<!-- toc -->
<ul>
<li><a href="#0----%25E5%259F%25BA%25E6%259C%25AC%25E6%25A6%2582%25E5%25BF%25B5">0
基本概念</a>
<ul>
<li><a href="#1Dx2F1D-%25E6%2596%25B9%25E7%25A8%258B">1D/1D
方程</a></li>
<li><a href="#2Dx2F1D-%25E6%2596%25B9%25E7%25A8%258B">2D/1D
方程</a></li>
</ul></li>
<li><a href="#1-----(1Dx2F1D)-%25E5%258D%2595%25E8%25B0%2583%25E9%2598%259F%25E5%2588%2597%25E4%25BC%2598%25E5%258C%2596">1
(1D/1D) 单调队列优化</a>
<ul>
<li><a href="#%25E6%25A6%2582%25E5%25BF%25B5">概念</a></li>
<li><a href="#(1)--%24ds%255Bj%255D%24-%25E4%25B8%258E-%24i%24-%25E6%2597%25A0%25E5%2585%25B3%25EF%25BC%259A%25E5%258D%2595%25E8%25B0%2583%25E9%2598%259F%25E5%2588%2597">(1)
<span class="math inline">\(ds[j]\)</span> 与 <span class="math inline">\(i\)</span> 无关：单调队列</a></li>
<li><a href="#(2)--%24ds%255Bj%255D%24-%25E4%25B8%258E-%24i%24-%25E6%259C%2589%25E5%2585%25B3%25EF%25BC%259A%25E4%25BA%258C%25E5%2588%2586%25E5%258D%2595%25E8%25B0%2583%25E6%25A0%2588">(2)
<span class="math inline">\(ds[j]\)</span> 与 <span class="math inline">\(i\)</span> 有关：二分单调栈</a></li>
<li><a href="#%25E5%258D%2595%25E8%25B0%2583%25E9%2598%259F%25E5%2588%2597%25E4%25BC%2598%25E5%258C%2596%25E6%25A8%25A1%25E6%259D%25BF%25E9%25A2%2598">单调队列优化模板题</a></li>
</ul></li>
<li><a href="#2----(1Dx2F1D)-%25E6%2596%259C%25E7%258E%2587x2F%25E5%2587%25B8%25E5%25A3%25B3%25E4%25BC%2598%25E5%258C%2596">2
(1D/1D) 斜率/凸壳优化</a>
<ul>
<li><a href="#%25E6%25A6%2582%25E5%25BF%25B5">概念</a></li>
<li><a href="#(1)-%24k%2Cx%24-%25E5%2590%258C%25E5%258D%2595%25E8%25B0%2583%25EF%25BC%259A%25E5%258D%2595%25E8%25B0%2583%25E9%2598%259F%25E5%2588%2597">(1)
<span class="math inline">\(k,x\)</span> 同单调：单调队列</a></li>
<li><a href="#(2)--%24k%24-%25E4%25B8%258D%25E5%258D%2595%25E8%25B0%2583%25EF%25BC%258C%24x%24-%25E5%258D%2595%25E8%25B0%2583%25EF%25BC%259A%25E4%25BA%258C%25E5%2588%2586%25E5%258D%2595%25E8%25B0%2583%25E6%25A0%2588">(2)
<span class="math inline">\(k\)</span> 不单调，<span class="math inline">\(x\)</span> 单调：二分单调栈</a></li>
<li><a href="#(3)--%24k%24-%25E5%258D%2595%25E8%25B0%2583%25EF%25BC%258C%24x%24-%25E4%25B8%258D%25E5%258D%2595%25E8%25B0%2583%25EF%25BC%259A%25E5%258A%25A8%25E6%2580%2581%25E5%2587%25B8%25E5%258C%2585">(3)
<span class="math inline">\(k\)</span> 单调，<span class="math inline">\(x\)</span> 不单调：动态凸包</a></li>
<li><a href="#(4)--%24k%24-%25E4%25B8%258D%25E5%258D%2595%25E8%25B0%2583%25EF%25BC%258C%24x%24-%25E4%25B8%258D%25E5%258D%2595%25E8%25B0%2583%25EF%25BC%259A%25E5%258A%25A8%25E6%2580%2581%25E5%2587%25B8%25E5%258C%2585">(4)
<span class="math inline">\(k\)</span> 不单调，<span class="math inline">\(x\)</span> 不单调：动态凸包</a></li>
<li><a href="#A.-%25E5%258A%25A8%25E6%2580%2581%25E5%2587%25B8%25E5%258C%2585%25EF%25BC%259A%25E6%259D%258E%25E8%25B6%2585%25E7%25BA%25BF%25E6%25AE%25B5%25E6%25A0%2591">A.
动态凸包：李超线段树</a></li>
<li><a href="#%25E6%2596%259C%25E7%258E%2587%25E4%25BC%2598%25E5%258C%2596%25E6%25A8%25A1%25E6%259D%25BF%25E9%25A2%2598">斜率优化模板题</a></li>
</ul></li>
<li><a href="#3-----(1Dx2F1D)-%25E5%2586%25B3%25E7%25AD%2596%25E5%258D%2595%25E8%25B0%2583%25E6%2580%25A7%25E4%25BC%2598%25E5%258C%2596">3
(1D/1D) 决策单调性优化</a>
<ul>
<li><a href="#%25E6%25A6%2582%25E5%25BF%25B5">概念</a></li>
<li><a href="#(1)-%25E6%2596%25B9%25E6%25B3%2595%25E4%25B8%2580%25EF%25BC%259A%25E5%258D%2595%25E8%25B0%2583%25E9%2598%259F%25E5%2588%2597-%2B-%25E4%25BA%258C%25E5%2588%2586">(1)
方法一：单调队列 + 二分</a></li>
<li><a href="#(2)-%25E6%2596%25B9%25E6%25B3%2595%25E4%25BA%258C%25EF%25BC%259A%25E5%2588%2586%25E6%25B2%25BB%25E6%25B3%2595">(2)
方法二：分治法</a></li>
<li><a href="#(3)-%25E6%2596%25B9%25E6%25B3%2595%25E4%25B8%2589%25EF%25BC%259ASMAWK-%25E7%25AE%2597%25E6%25B3%2595">(3)
方法三：SMAWK 算法</a></li>
<li><a href="#(4)-%25E6%2596%25B9%25E6%25B3%2595%25E5%259B%259B%25EF%25BC%259AWilber-%25E7%25AE%2597%25E6%25B3%2595">(4)
方法四：Wilber 算法</a></li>
<li><a href="#(5)-%25E6%2596%25B9%25E6%25B3%2595%25E4%25BA%2594%25EF%25BC%259AEppstein-%25E7%25AE%2597%25E6%25B3%2595">(5)
方法五：Eppstein 算法</a></li>
<li><a href="#%25E5%2586%25B3%25E7%25AD%2596%25E5%258D%2595%25E8%25B0%2583%25E6%2580%25A7%25E6%25A8%25A1%25E6%259D%25BF%25E9%25A2%2598">决策单调性模板题</a></li>
<li><a href="#%25E5%2586%25B3%25E7%25AD%2596%25E5%258D%2595%25E8%25B0%2583%25E6%2580%25A7%25E7%25BB%2583%25E4%25B9%25A0%25E9%25A2%2598">决策单调性练习题</a></li>
</ul></li>
<li><a href="#4-----(2Dx2F1D)-%25E5%259B%259B%25E8%25BE%25B9%25E5%25BD%25A2%25E4%25B8%258D%25E7%25AD%2589%25E5%25BC%258F%25E4%25BC%2598%25E5%258C%2596">4
(2D/1D) 四边形不等式优化</a></li>
<li><a href="#5-----(2Dx2F1D)-WQS%25E5%25B8%25A6%25E6%259D%2583%25E4%25BA%258C%25E5%2588%2586%25E4%25BC%2598%25E5%258C%2596">5
(2D/1D) WQS带权二分优化</a>
<ul>
<li><a href="#%25E9%25A2%2598%25E7%259B%25AE%25E7%25B1%25BB%25E5%259E%258B">题目类型</a></li>
<li><a href="#%25E6%259C%25B4%25E7%25B4%25A0DP%25E6%2580%259D%25E8%25B7%25AF">朴素DP思路</a></li>
<li><a href="#WQS%25E4%25BA%258C%25E5%2588%2586%25E8%25A7%25A3%25E9%25A2%2598%25E6%2580%259D%25E8%25B7%25AF">WQS二分解题思路</a></li>
<li><a href="#WQS%25E4%25BA%258C%25E5%2588%2586%25E6%25A8%25A1%25E6%259D%25BF%25E9%25A2%2598">WQS二分模板题</a></li>
<li><a href="#WQS%25E4%25BA%258C%25E5%2588%2586%25E7%25BB%2583%25E4%25B9%25A0%25E9%25A2%2598">WQS二分练习题</a></li>
</ul></li>
<li><a href="#6----(2Dx2F0D)-%25E7%259F%25A9%25E9%2598%25B5%25E4%25B9%2598%25E6%25B3%2595%25E4%25BC%2598%25E5%258C%2596">6
(2D/0D) 矩阵乘法优化</a></li>
<li><a href="#7----(1Dx2F1D)-%25E9%2597%25B5%25E5%258F%25AF%25E5%25A4%25AB%25E6%2596%25AF%25E5%259F%25BA%25E5%2592%258C%25E4%25BC%2598%25E5%258C%2596">7
(1D/1D) 闵可夫斯基和优化</a>
<ul>
<li><a href="#%25E6%25A6%2582%25E8%25BF%25B0">概述</a></li>
<li><a href="#%25E7%25AE%2597%25E6%25B3%2595%25E6%25B5%2581%25E7%25A8%258B">算法流程</a></li>
<li><a href="#%25E4%25BC%2598%25E5%258C%2596-DP">优化 DP</a></li>
<li><a href="#%25E4%25BE%258B%25E9%25A2%2598">例题</a></li>
<li><a href="#%25E5%258F%2582%25E8%2580%2583%25E8%25B5%2584%25E6%2596%2599">参考资料</a></li>
</ul></li>
<li><a href="#8-----(1Dx2F1D)-Slope-Trick">8 (1D/1D) Slope Trick</a>
<ul>
<li><a href="#%25E6%25A6%2582%25E8%25BF%25B0">概述</a></li>
<li><a href="#%25E4%25BE%258B%25E9%25A2%2598">例题</a></li>
</ul></li>
<li><a href="#9-----(xDx2FyD)-%25E6%2595%25B0%25E6%258D%25AE%25E7%25BB%2593%25E6%259E%2584%25E4%25BC%2598%25E5%258C%2596">9
(xD/yD) 数据结构优化</a></li>
</ul>
<!-- tocstop -->
<h2 id="基本概念">0 基本概念</h2>
<p>我们对DP的状态转移方程按照<strong>状态维度</strong>和<strong>决策点维度</strong>（转移点维度），分为
1D/1D 和 2D/1D 。</p>
<h3 id="d1d-方程">1D/1D 方程</h3>
<p>1D/1D 方程，意思是我们计算的 <span class="math inline">\(dp[i]\)</span> 的状态维度是 1 维的 <span class="math inline">\([i]\)</span> ，决策点的维度是 1 维的 <span class="math inline">\([j]\)</span> 。</p>
<p>状态转移方程：</p>
<p><span class="math display">\[
\begin{align}
f(i)&amp;=\min/\max\limits_{}\{g(j)+w(i,j)\},\quad 1\le j &lt; i
\end{align}
\]</span></p>
<p>我们按照 <span class="math inline">\(w(i,j)\)</span>
的性质继续细分：</p>
<h4 id="wij-为多项式函数">(1) <span class="math inline">\(w(i,j)\)</span> 为多项式函数</h4>
<h5 id="a.-wij-为一次函数单调队列优化">a. <span class="math inline">\(w(i,j)\)</span> 为一次函数：单调队列优化</h5>
<h5 id="b.-wij-为高次函数斜率凸壳优化">b. <span class="math inline">\(w(i,j)\)</span> 为高次函数：斜率/凸壳优化</h5>
<blockquote>
<p>其中根据 <span class="math inline">\(w(i,j)\)</span>
的情况，有不同的优化策略：</p>
<ol type="1">
<li>单调队列</li>
<li>二分队列</li>
<li>动态凸包：CDQ分治、线段树维护、李超线段树</li>
</ol>
</blockquote>
<h4 id="wij-为非多项式函数">(2) <span class="math inline">\(w(i,j)\)</span> 为非多项式函数</h4>
<h5 id="a.-wij-满足四边形不等式决策单调性优化">a. <span class="math inline">\(w(i,j)\)</span>
满足四边形不等式：决策单调性优化</h5>
<blockquote>
<p>其中根据 <span class="math inline">\(w(i,j)\)</span>
的单调性，有不同的优化策略：</p>
<ol type="1">
<li>单调队列（有单调性）</li>
<li>二分队列（无单调性）</li>
<li>CDQ分治（无单调性）</li>
</ol>
</blockquote>
<h3 id="d1d-方程-1">2D/1D 方程</h3>
<p>2D/1D 方程，意思是我们计算的 <span class="math inline">\(dp[i][j]\)</span> 的状态维度是 2 维的 <span class="math inline">\([i][j]\)</span> ，决策点的维度是 1 维的 <span class="math inline">\([k]\)</span> 。</p>
<p>状态转移方程：</p>
<p><span class="math display">\[
\begin{align}
f(i,j) &amp;= \min/\max\{g(i,k)+h(k,j)+w(i,j)\},\quad k \in [i,j-1]
\end{align}
\]</span></p>
<p>如果决策点 <span class="math inline">\([k]=[j]\)</span>
，则状态转移方程：</p>
<p><span class="math display">\[
f(i,j) = \min/\max\{g(i,j)+w(i,j)\},\quad j \in [1,i]
\]</span></p>
<p>我们继续细分：</p>
<h4 id="fij-具有凸性">(1) <span class="math inline">\(f(i,j)\)</span>
具有凸性</h4>
<p>WQS带权二分</p>
<h4 id="wij-满足四边形不等式">(2) <span class="math inline">\(w(i,j)\)</span> 满足四边形不等式</h4>
<p>四边形不等式优化（区间决策单调性）</p>
<h2 id="d1d-单调队列优化">1 (1D/1D) 单调队列优化</h2>
<h3 id="概念">概念</h3>
<h3 id="dsj-与-i-无关单调队列">(1) <span class="math inline">\(ds[j]\)</span> 与 <span class="math inline">\(i\)</span> 无关：单调队列</h3>
<p><strong>单调队列优化特征状态方程：</strong></p>
<p><span class="math display">\[
\begin{align}
dp[i]&amp;=\min/\max\{dp[j]+a[i]+b[j]\}, \quad j \in[L(i),R(i)] \\
&amp;=\min/\max\{dp[j]+b[j]\} +a[i] \\
\end{align}
\]</span></p>
<p>设 <span class="math inline">\(ds[j]= dp[j]+b[j]\)</span>，其中 <span class="math inline">\(ds[j]\)</span> 的计算与 <span class="math inline">\(i\)</span> <strong>完全无关</strong>。可得：</p>
<p><span class="math display">\[
dp[i]=\min/\max\{ds[j]\} +a[i], \quad j \in[L(i),R(i)]
\]</span></p>
<p>由于 <span class="math inline">\(ds[j]\)</span> 仅和 <span class="math inline">\(j\)</span> 有关，与 <span class="math inline">\(i\)</span> 无关，故 <span class="math inline">\(ds[j]\)</span> 仅需计算一次即可用于全部 <span class="math inline">\(dp[i]\)</span> 的计算中。</p>
<p>未优化前，在每一轮 <span class="math inline">\(i\)</span>
的循环中都要计算一遍 <span class="math inline">\(\min/\max\{ds[j]\}，j
\in[L(i),R(i)]\)</span> ，期间有大量重复的 <span class="math inline">\(ds[j]\)</span> 计算。故考虑用单调队列存储 <span class="math inline">\(\min/\max\{ds[j]\}，j \in[L(i),R(i)]\)</span>
。单调队列可用于数组上的滑动窗口，此处 <span class="math inline">\(j
\in[L(i),R(i)]\)</span> 也是一个滑动窗口，求滑动窗口内的最值。</p>
<p>我们可在遍历 <span class="math inline">\(i\)</span> 的同时计算当前的
<span class="math inline">\(\min/\max\{ds[j]\}，j\in
[R(i-1)+1,R(i)]\)</span> ，将当前计算出的值逐个压入单调队列。</p>
<ul>
<li>如果是当前的最值，就将前面计算的值全部弹走，队首为该最值</li>
<li>如果不是当前的最值，压入队尾，作为未来可能的最值。</li>
<li>检查队首的值是否在滑动窗口范围外，将 <span class="math inline">\(ds[j]，j\in [1，R(i-1)]\)</span> 弹出队首。</li>
</ul>
<p>实际中，单调队列储存的值为 <span class="math inline">\(ds\)</span>
的下标 <span class="math inline">\(j\)</span>， <span class="math inline">\(ds[j]= dp[j]+b[j]\)</span> 可以不额外存储。</p>
<blockquote>
<p>请注意： <span class="math inline">\(ds[j]\)</span> 的计算必须完全与
<span class="math inline">\(i\)</span> 无关！</p>
</blockquote>
<h3 id="dsj-与-i-有关二分单调栈">(2) <span class="math inline">\(ds[j]\)</span> 与 <span class="math inline">\(i\)</span> 有关：二分单调栈</h3>
<p>如上面的注解中提到， <span class="math inline">\(ds[j]\)</span>
的计算必须完全与 <span class="math inline">\(i\)</span> 无关。这使得 LIS
问题无法使用单调队列解决。</p>
<p>LIS 问题的通常解法是：设 <span class="math inline">\(dp[i]\)</span>
为前 <span class="math inline">\(i\)</span>
个元素的最长上升子序列长度，则有</p>
<p><span class="math display">\[
dp[i]=\max\{dp[j]\}+1, ~j \in(0,i),~a[j]\le a[i]
\]</span></p>
<p>看似方程符合单调队列优化，但是有 <span class="math inline">\(a[j]\le
a[i]\)</span> 的限制条件，这就使得 <span class="math inline">\(dp[j]\)</span> 的计算与 <span class="math inline">\(i\)</span>
有关了，无法使用单调队列优化。朴素的解法是 <span class="math inline">\(O(n^2)\)</span> 的时间复杂度。</p>
<p>我们重新设置状态，令 <span class="math inline">\(dp[i]\)</span>
表示长度为 <span class="math inline">\(i\)</span>
的上升子序列的最后一个元素的最小值，则有：</p>
<p><span class="math display">\[
dp[i]=\min\{dp[j]\}+1, ~j \in[1,i),~dp[j]&lt;a[i]
\]</span></p>
<p>这时候我们考虑每次计算 <span class="math inline">\(dp[i]\)</span>
时都通过二分来搜索 <span class="math inline">\(dp[j]\)</span>
的最大值。</p>
<ul>
<li>为每个 <span class="math inline">\(dp[j]\)</span>
记录该子序列的最后一个元素的值。</li>
<li>同时若子序列长度相同，则记录最后一个元素是最小的那个。</li>
<li>根据 <span class="math inline">\(a[i]\)</span> 二分搜索 <span class="math inline">\(dp[j]\)</span> ，找到最后一个 <span class="math inline">\(\le a[i]\)</span> 的 <span class="math inline">\(dp[j]\)</span> 。</li>
<li>然后更新 <span class="math inline">\(dp[i]=dp[j]+1\)</span> ，记录
<span class="math inline">\(a[i]\)</span> 为 <span class="math inline">\(dp[i]\)</span> 对应子序列的最后一个元素。</li>
</ul>
<p>这样的时间复杂度为 <span class="math inline">\(O(n\log n)\)</span>
。</p>
<p>虽然没有人称其为二分单调栈，通常只称为<strong>二分解法</strong>，但其实个人感觉比较相似，同时为了和斜率优化对应，这里也称为二分单调栈。</p>
<h3 id="单调队列优化模板题">单调队列优化模板题</h3>
<h4 id="单调队列p2627-usaco11open-mowing-the-lawn-g">1. 【单调队列】<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2627">P2627 USACO11OPEN Mowing
the Lawn G</a></h4>
<p><strong>题意概述</strong></p>
<p>有一个包括 <span class="math inline">\(n\)</span> 个正整数的序列，第
<span class="math inline">\(i\)</span> 个整数为 <span class="math inline">\(E_i\)</span> ，给定一个整数 <span class="math inline">\(k\)</span>
，找这样的子序列，如果子序列中的数在原序列中连续，则连续长度不能超过
<span class="math inline">\(k\)</span>
。对于子序列求和，问所有子序列中最大的和是多少？</p>
<p><strong>单调队列题解</strong></p>
<p>设 <span class="math inline">\(dp[i]\)</span> 为前 <span class="math inline">\(i\)</span>
个整数的最大子序列和，则状态转移方程为：</p>
<p><span class="math display">\[
dp[i] = \max \{dp[j-1]+sum[i]-sum[j]\},\quad  j \in [i-k,i]
\]</span></p>
<p>其中 <span class="math inline">\(sum[i]\)</span> 是前缀和，<span class="math inline">\(sum[i]-sum[j]\)</span> 求的是 <span class="math inline">\([i-k,i]\)</span> 区间和。</p>
<p>根据单调队列优化：</p>
<p><span class="math display">\[
\begin{align}
dp[i] &amp;= \max \{dp[j-1]-sum[j]\}+sum[i],\quad  j \in [i-k,i] \\
&amp;=\max \{ds[j]\}+sum[i]
\end{align}
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100007</span>;<br>ll n, k, e[N], sum[N], dp[N];<br>ll ds[N];<br><span class="hljs-comment">// 单调队列，为了简便没有写为循环队列，head</span><br><span class="hljs-comment">// 由于这里是求最大值，故 ds[q[tail]] &lt; ds[j] 为从队首到队尾的单调递减队列</span><br><span class="hljs-comment">// 如果是求最小值，则为从队首到队尾的单调递增队列，即 ds[q[tail]] &gt; ds[j]</span><br><span class="hljs-comment">// q[head] &lt; j - k 为了保证队列中的元素都在滑动窗口[i - k, i] (j == i)内</span><br><span class="hljs-comment">// head 指向队首元素，tail指向队尾元素，当队中没有元素时，tail = head - 1</span><br><span class="hljs-type">int</span> q[N], head = <span class="hljs-number">0</span>, tail = <span class="hljs-number">-1</span>;<br><span class="hljs-function">ll <span class="hljs-title">monoQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> j)</span> </span>&#123;<br>    ds[j] = dp[j - <span class="hljs-number">1</span>] - sum[j];<br>    <span class="hljs-keyword">while</span> (head &lt;= tail &amp;&amp; ds[q[tail]] &lt; ds[j])<br>        tail--;  <span class="hljs-comment">// ds[j]从队尾进入，经过比它小的值就删去</span><br>    q[++tail] = j;<br>    <span class="hljs-keyword">while</span> (head &lt;= tail &amp;&amp; q[head] &lt; j - k)<br>        head++;<br>    <span class="hljs-keyword">return</span> ds[q[head]];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    sum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; e[i];<br>        sum[i] = sum[i - <span class="hljs-number">1</span>] + e[i];<br>    &#125;<br>    <span class="hljs-built_in">monoQueue</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 初始化单调队列 ds[0] = dp[-1] - sum[0] = 0 - 0 = 0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        dp[i] = <span class="hljs-built_in">monoQueue</span>(i) + sum[i];<br>    cout &lt;&lt; dp[n];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="二分单调栈">2. 【二分单调栈】</h4>
<h2 id="d1d-斜率凸壳优化">2 (1D/1D) 斜率/凸壳优化</h2>
<h3 id="概念-1">概念</h3>
<p><strong>斜率/凸壳优化特征状态方程：</strong></p>
<p><span class="math display">\[
dp[i]=\min \{dp[j]-a[i]d[j]\}, \quad j \in [0,i-1], \quad a[i] \le
a[i+1], \quad d[j]\le d[j+1]
\]</span></p>
<p>特点：存在一个既有 <span class="math inline">\(i\)</span> 又有 <span class="math inline">\(j\)</span> 的项 <span class="math inline">\(a[i]d[j]\)</span> ，并且 <span class="math inline">\(a[i]\)</span> 和 <span class="math inline">\(d[j]\)</span> 都是单调不减， <span class="math inline">\(j \in [0,i-1]\)</span> 。</p>
<p><span class="math display">\[
\begin{align}
\because dp[i] &amp;= dp[j] - a[i]d[j] \\
\therefore dp[j] &amp;= a[i]d[j] + dp[i] \\
\end{align}
\]</span></p>
<p><span class="math display">\[
设~y=dp[j],x=d[j],k=a[i],b=dp[i],~得:\\
y=kx+b
\]</span></p>
<p>其中 <span class="math inline">\(b=dp[i]\)</span>
是我们要求的值，并且要是最小值，故最小化 <span class="math inline">\(dp[i]\)</span> 的问题转化为：</p>
<ul>
<li>对于 <span class="math inline">\(j \in [0,i)\)</span> 中的不同的
<span class="math inline">\(j\)</span> ，会产生一系列点 <span class="math inline">\((d[j],dp[j])=(x_j,y_j)\)</span>
分布在平面上。</li>
<li>寻找 <span class="math inline">\((x_j,y_j)\)</span> ，在斜率 <span class="math inline">\(k=a[i]\)</span> 的情况下，能够使截距 <span class="math inline">\(b=dp[i]\)</span> 达到最小值。</li>
</ul>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/monoqueue1_200-1712573757009-1.svg" srcset="/img/loading.gif" lazyload alt="寻找最小的 b">
<figcaption aria-hidden="true">寻找最小的 <span class="math inline">\(b\)</span></figcaption>
</figure>
<p>通过构造“<strong>凸壳</strong>”的技巧，我们可以很快寻找到使截距 <span class="math inline">\(b=dp[i]\)</span> 达到最小值的 <span class="math inline">\((x_j,y_j)\)</span>。</p>
<p>我们设这个最优点为 <span class="math inline">\(P_i=(x_j,y_j)\)</span>
（下标为 <span class="math inline">\(i\)</span> 表示它是根据 <span class="math inline">\(k=a[i]\)</span> 来寻找的）</p>
<p>这个点一定在下凸壳上，并且它与前一个点的斜率 <span class="math inline">\(\le k\)</span> ，与后一个点的斜率 <span class="math inline">\(\ge k\)</span>
（也可能是是凸壳中第一个或最后一个点，当所有线段的斜率都 <span class="math inline">\(\le k\)</span> 或 <span class="math inline">\(\ge
k\)</span>）。</p>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/monoqueue2_200-1712573757009-2.svg" srcset="/img/loading.gif" lazyload alt="下凸壳">
<figcaption aria-hidden="true">下凸壳</figcaption>
</figure>
<p>当我们随着 <span class="math inline">\(i\)</span> 的遍历，计算最新的
<span class="math inline">\(j \in [0,i)\)</span> 对应的 <span class="math inline">\((x_j,y_j)\)</span>
并加入到平面上时，凸壳上的点会不断更新，以确保它一直是凸壳。比如点 3 在
<span class="math inline">\(i = 3\)</span>
时是最新的点，它与1、2、3组成凸壳，但是当 <span class="math inline">\(i
= 4\)</span> 时，随着点 4 的加入，点 3 被排除，1、2、4重新组成凸壳。</p>
<mydetails>
<summary>
<summary-title>Algorithm</summary-title><summary-subtitle>凸包构造算法</summary-subtitle>
</summary>
<p>这种算法为计算几何中一种简单的凸包算法：安德鲁算法（Andrew's
Algorithm）</p>
<p>这个是利用单调队列以及斜率的单调性来得到凸包。</p>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/R6VuVuU-1712573757009-3.gif" srcset="/img/loading.gif" lazyload alt="Andrew&#39;s Algorithm 构建凸包的过程">
<figcaption aria-hidden="true">Andrew's Algorithm
构建凸包的过程</figcaption>
</figure>
<p>另有别的凸包构建算法：Graham’s Scan</p>
<p>先找到最左下的点（y
最小的最左边的点），计算其他点以该点为原点的极角，并用极角对点进行排序。同样用一个单调队列来维护凸包上的点。</p>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/5rtTjsI-1712573757009-4.gif" srcset="/img/loading.gif" lazyload alt="Graham’s Scan 构建凸包的过程">
<figcaption aria-hidden="true">Graham’s Scan 构建凸包的过程</figcaption>
</figure>
<p>两者时间复杂度受限于排序，为 <span class="math inline">\(O(n\log
n)\)</span> 。由于这里给出的 <span class="math inline">\(x=d[j]\le
d[j+1]\)</span> ，所以省去了排序的过程。</p>
<p></p></mydetails><p></p>
<p>对于计算 <span class="math inline">\(dp[i] = b_{\min}\)</span>
，我们就在斜率 <span class="math inline">\(k=a[i]\)</span>
的情况下，<strong>从左到右遍历</strong>凸壳上的点寻找最优 <span class="math inline">\((x_j,y_j)\)</span> 。该项时间复杂度为 <span class="math inline">\(O(n)\)</span>。考虑 <span class="math inline">\(i\)</span> 有 <span class="math inline">\(n\)</span> 次循环，总时间复杂度为 <span class="math inline">\(O(n^2)\)</span>。</p>
<blockquote>
<p>到目前为止，相较于普通的DP方法，我们仅仅是用凸壳来改进了 <span class="math inline">\((x_j,y_j)\)</span>
的一部分搜索范围（即只搜索凸壳上的点）。最好情况下是 $(n) $
，即凸壳上总是只有 1 个点；在最坏情况下，所有点都在凸壳上，时间复杂度为
$(n^2) $</p>
<p>怎么进一步优化呢？</p>
<p>想要优化，那么我们必须要让 <span class="math inline">\(k=a[i]\)</span> 以及 <span class="math inline">\(x=d[j]\)</span> 满足一些性质，让我们能够以优于
<span class="math inline">\(O(n)\)</span>
的时间在凸壳找到最优决策点。最常见的性质为单调性。下面从单调性这一性质展开优化。</p>
</blockquote>
<mydetails>
<summary>
<summary-title>More</summary-title><summary-subtitle>斜率优化推导练习</summary-subtitle>
</summary>
<p><strong>练习1</strong></p>
<p><span class="math display">\[
dp[i]=\min\limits_{j=1}^{i-1}\{a[i]\cdot x[j]+b[i]\cdot y[j]\} +
w[i],~其中~x[j],y[j]~可由~dp[j]~在O(1)时间内唯一确定
\]</span></p>
<p>推导为 <span class="math inline">\(y=kx+b\)</span> 形式：</p>
<p><span class="math display">\[
\begin{align}
\frac{dp[i]}{a[i]}&amp;=x[j]+\frac{b[i]}{a[i]}\cdot y[j] +
\frac{w[i]}{a[i]}\\
x[j]&amp;=-\frac{b[i]}{a[i]}\cdot
y[j]+\left(\frac{dp[i]}{a[i]}-\frac{w[i]}{a[i]}\right)\\
\end{align}
\]</span></p>
<hr>
<p></p></mydetails><p></p>
<h3 id="kx-同单调单调队列">(1) <span class="math inline">\(k,x\)</span>
同单调：单调队列</h3>
<p>如果最开始给出的特征状态方程还有这样的性质：</p>
<p><span class="math display">\[
a[i] \le a[i+1], \quad d[j]\le d[j+1]
\]</span></p>
<ul>
<li><p><span class="math inline">\(k=a[i]\)</span>
是单调不减的。假设上一轮斜率是 <span class="math inline">\(k_{i-1}\)</span> ，找到了最优点 <span class="math inline">\(P_{i-1}\)</span>，下一轮的斜率 <span class="math inline">\(k_i \ge
k_{i-1}\)</span>，此时凸壳上的<strong>最优点 <span class="math inline">\(P_{i}\)</span> 必然在 <span class="math inline">\(P_{i-1}\)</span>
的右侧或它本身</strong>。因此凸壳上 <span class="math inline">\(P_{i-1}\)</span>
之前的点不用遍历了，直接跳过。</p>
<blockquote>
<p>凸壳上 <span class="math inline">\(P_{i-1}\)</span>
之前的点也可以删除，即使新加入的点使得之前的凸壳发生了变化，我们搜索的起始点也没有变化</p>
</blockquote></li>
<li><p><span class="math inline">\(x=d[j]\)</span> 也是单调不减的。说明
<span class="math inline">\((x_j,y_j)\)</span> 在平面上从左往右是按照
<span class="math inline">\(j\)</span>
从小到大的顺序来分布的。也就是说<strong>新加入的点 <span class="math inline">\((x_j,y_j)\)</span>
只会在最右侧，不会跑到左边破坏我们的凸壳</strong>。这样就保证了我们只需要根据凸壳末端的点和新加入的点进行斜率比较即可决定凸壳的更新方式。（与此同时，也支持形成单调队列的结构）</p></li>
</ul>
<p>因此，我们只需用<strong>单调队列</strong>在点一个个被加入时维护凸壳，即可根据上一轮的
<span class="math inline">\(P_{i-1}\)</span> 以 <span class="math inline">\(O(1)\)</span> 找到这一轮的 <span class="math inline">\(P_{i}\)</span> 。</p>
<blockquote>
<p>因为每轮只有一个点新加入平面，我们从上一轮的最优点开始往凸壳右边找，很快就能找到。
而且最终查询的点数小于凸壳上所有曾经加入的点数。</p>
</blockquote>
<p>最终，<span class="math inline">\(i\)</span> 的遍历为 <span class="math inline">\(O(n)\)</span> ，每次寻找 <span class="math inline">\(dp[i] = b_{\min}\)</span> 在凸壳上对应的最优点
<span class="math inline">\(P_{i}\)</span> 的时间为 <span class="math inline">\(O(1)\)</span> ，总时间复杂度为 <span class="math inline">\(O(n)\)</span> 。</p>
<blockquote>
<p>思考：如果两者都是单调不增呢？</p>
<p><span class="math display">\[
dp[i]=\min \{dp[j]-a[i]d[j]\}, \quad j \in [0,i-1],\quad a[i] \ge
a[i+1], \quad d[j]\ge d[j+1]
\]</span></p>
<p>这样，其实依然是下凸壳，只是从<strong>点在平面上的分布</strong>来看，遍历顺序（
<span class="math inline">\([0,i-1]\)</span>
）从原来的【由左到右】变为了【由右到左】而已。我们维护凸壳的时候，要按照斜率递减的方式维护。</p>
</blockquote>
<p><strong>斜率/凸壳优化模板代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-comment">// 删除凸壳上在最优点Pi左边的点，剩下的队列的队首即为最优点Pi</span><br>    <span class="hljs-keyword">while</span> (head &lt; tail &amp;&amp; <span class="hljs-built_in">slope</span>(q[head], q[head+<span class="hljs-number">1</span>]) &lt; k) head++;<br>    <span class="hljs-comment">// 根据最优点Pi计算dp[i] = b_min</span><br>    <span class="hljs-type">int</span> j = q[head];<br>    dp[i] = ...;<br>    <span class="hljs-comment">// 下一轮的点(x_j,y_j)(j = i)加入图中，并更新凸壳（因为j &lt; i，所以这里是下一轮）</span><br>    <span class="hljs-keyword">while</span> (head &lt; tail &amp;&amp; <span class="hljs-built_in">slope</span>(i, q[tail<span class="hljs-number">-1</span>]) &lt; <span class="hljs-built_in">slope</span>(q[tail<span class="hljs-number">-1</span>], q[tail])) tail--;<br>    q[++tail] = i; <span class="hljs-comment">// 加入队尾</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面的代码计算的顺序和前面我们描述的过程不太一样，主要是因为 <span class="math inline">\(0 \le j &lt; i\)</span>。</p>
<h3 id="k-不单调x-单调二分单调栈">(2) <span class="math inline">\(k\)</span> 不单调，<span class="math inline">\(x\)</span> 单调：二分单调栈</h3>
<p>即：</p>
<p><span class="math display">\[
dp[i]=\min \{dp[j]-a[i]d[j]\}, \quad j \in [0,i-1], \quad
a[i]~\text{无单调性},\quad d[j]\le d[j+1]
\]</span></p>
<ul>
<li><span class="math inline">\(k=a[i]\)</span>
无单调性。这意味着我们无法从上一轮的最优点开始，直接往后在凸壳上找到这一轮的最优点。也就是说，必须搜索当前的整个凸壳！</li>
<li><span class="math inline">\(x=d[j]\)</span>
单调不减。说明凸壳的维护还是按照（1）中的 Andrew 算法即可，</li>
</ul>
<p>此时我们必须搜索整个凸壳了，计算凸壳上每两个点构成的直线的斜率。根据（1）中的分析，我们知道，凸壳上的这个“斜率”是单调不减的，对于有序数列的搜索，可以使用二分搜索来优化至
<span class="math inline">\(O(\log n)\)</span> ，我们总共要计算 n 次
<span class="math inline">\(dp[i]\)</span> ，所以总共的时间复杂度为
<span class="math inline">\(O(n\log n)\)</span> 。</p>
<p>因为没有对队首的操作，<strong>单调队列成了单调栈</strong>。</p>
<p>唯一要注意的就是：凸壳上有<strong>多点共线</strong>的情况。二分搜索是搜索不到共线的中间的点的，只能搜索到两边的点，并且取哪一边需要看题目的要求如何。</p>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/monoqueue3_200-1712573757009-5.svg" srcset="/img/loading.gif" lazyload alt="有多点共线">
<figcaption aria-hidden="true">有多点共线</figcaption>
</figure>
<h3 id="k-单调x-不单调动态凸包">(3) <span class="math inline">\(k\)</span> 单调，<span class="math inline">\(x\)</span> 不单调：动态凸包</h3>
<p>即满足：</p>
<p><span class="math display">\[
a[i] \le a[i+1],\quad d[j]~\text{无单调性}
\]</span></p>
<ul>
<li><p><span class="math inline">\(k=a[i]\)</span>
单调不减。受到动态凸包的影响，用不太上，基本可以忽略。每一轮搜索的斜率单调不减，则可以：</p>
<ul>
<li>如果这一轮加入的点未破坏上一轮的最优点，则从上一轮的最优点开始二分</li>
<li>如果这一轮加入的点破坏了上一轮的最优点，则从该点开始二分</li>
</ul>
<p>但实际上这样做只是优化了一点点常数，<strong>没什么必要</strong>，我们二分的
<span class="math inline">\(\log n\)</span> 已经足够快了。</p>
<p>所以一般忽略这个性质，<strong>直接二分即可</strong>。</p></li>
<li><p><span class="math inline">\(x=d[j]\)</span>
无单调性。说明凸壳的维护不能使用 Andrew
算法。此时变成了<strong>动态凸包</strong>问题，考虑使用算法：</p>
<ul>
<li>树状数组、线段树优化：参考最长递增子序列（LIS）问题（<span class="math inline">\(dp[i] = max\{dp[j]\}+1\)</span>）。</li>
<li>李超线段树</li>
<li>CDQ分治</li>
<li>set维护凸包</li>
</ul></li>
</ul>
<p>最终基本上是 <span class="math inline">\(O(n\log n)\)</span>
的时间复杂度。</p>
<h3 id="k-不单调x-不单调动态凸包">(4) <span class="math inline">\(k\)</span> 不单调，<span class="math inline">\(x\)</span> 不单调：动态凸包</h3>
<p>和（3）的情况几乎一样。</p>
<h3 id="a.-动态凸包李超线段树">A. 动态凸包：李超线段树</h3>
<hr>
<h3 id="斜率优化模板题">斜率优化模板题</h3>
<h4 id="单调队列print-article-hdu3507">1. 【单调队列】<a target="_blank" rel="noopener" href="https://vjudge.net/problem/HDU-3507#author=yizhexu">Print Article
HDU3507</a></h4>
<p><strong>题意概述</strong></p>
<p>打印一篇有 <span class="math inline">\(N\)</span>
个字的文章，每个字i的打印成本是 <span class="math inline">\(C_i\)</span>。此外，在一行中打印 <span class="math inline">\(k\)</span> 个字将花费: <span class="math inline">\((\sum\limits_{i=1}^{k} C_i)^2 + M\)</span>。 <span class="math inline">\(M\)</span>
是一个常数。你的任务是找到一种最佳的打印方式，使得总的打印成本最小。</p>
<p><strong>斜率优化+单调队列解题思路</strong></p>
<p>设 <span class="math inline">\(dp[i]\)</span> 为前 <span class="math inline">\(i\)</span> 个单词的最低成本，<span class="math inline">\(sum[i]\)</span> 为前缀和。</p>
<p><span class="math display">\[
\begin{align*}
     \because dp[i] &amp;= \min(dp[j] + (sum[i] - sum[j])^2 + M) \\
       &amp;= \min(dp[j] + sum[i]^2 - 2 \times sum[i] \times sum[j] +
sum[j]^2 + M) \\
\therefore(dp[i] - sum[i]^2)  &amp;= \min(dp[j] + sum[j]^2 - 2 \times
sum[i] \times sum[j]) + M \\
     &amp;= (dp[j] + sum[j]^2) - (2 \times sum[i] \times sum[j]) + M \\
\therefore(dp[j] + sum[j]^2)  &amp;= (2 \times sum[i] \times sum[j]) +
(dp[i] - sum[i]^2) - M \\
\end{align*}
\]</span></p>
<p><span class="math display">\[
设~ y = dp[j] + sum[j]^2,~ x = sum[j],~ k = 2 \times sum[i],~ b = dp[i]
- sum[i]^2 - m,~则有：
\]</span></p>
<p><span class="math display">\[
y=kx+b
\]</span></p>
<p><span class="math inline">\(x=sum[j]\)</span> 和 <span class="math inline">\(k=2\times sum[i]\)</span>
都是单调不减，满足斜率优化的要求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">500007</span>;<br><span class="hljs-type">int</span> n, m, c[N], sum[N], dp[N];  <span class="hljs-comment">// dp[i] 表示前 i 个字的最小打印成本</span><br><span class="hljs-type">int</span> q[N], head, tail;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> K(p) (2 * sum[i])</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> X(p) (sum[p])</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Y(p) (dp[p] + sum[p] * sum[p])</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> B(p) (dp[i] - sum[i] * sum[i] - m)</span><br><span class="hljs-comment">// le -&gt; less or equal (&lt;=) , ge -&gt; greater or equal (&gt;=)</span><br><span class="hljs-comment">// lt -&gt; less than (&lt;) , gt -&gt; greater than (&gt;)</span><br><span class="hljs-comment">// 以下两行可以避免除法（除法会有误差和除数为0的情况）</span><br><span class="hljs-comment">// 一定要注意p1和p2的顺序，p1在p2的右边，即p1的x坐标大于p2的x坐标，否则斜率算的是反的</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> slope_le_k(p1, p2 ,k) ((Y(p1) - Y(p2)) &lt;= (X(p1) - X(p2)) * (k))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> k1_le_k2(p1, p2, p3, p4) ((Y(p1) - Y(p2)) * (X(p3) - X(p4)) &lt;= (Y(p3) - Y(p4)) * (X(p1) - X(p2)))</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; m) &#123;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        sum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            cin &gt;&gt; c[i];<br>            sum[i] = sum[i - <span class="hljs-number">1</span>] + c[i];<br>        &#125;<br>        head = <span class="hljs-number">1</span>, tail = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化单调队列: 放入一个元素0 (也抛弃了q[0]，选择下标从1开始)</span><br>        q[tail] = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 这里是 j == 0的情况，只有一个点，所以不需要判断斜率直接放入</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-comment">// 这里不能是 head &lt;= tail ！！！因为至少要有两个元素才能计算斜率</span><br>            <span class="hljs-comment">// 并且也可能是特殊情况：当所有线段的斜率都 &lt;= k 时，此时队列必须剩下一个元素</span><br>            <span class="hljs-comment">// 注意q[head + 1], q[head]的顺序，确保斜率不要反了！！！</span><br>            <span class="hljs-keyword">while</span> (head &lt; tail &amp;&amp; <span class="hljs-built_in">slope_le_k</span>(q[head + <span class="hljs-number">1</span>], q[head], <span class="hljs-built_in">K</span>(i))) head++;   <br>            <span class="hljs-type">int</span> j = q[head];    <span class="hljs-comment">// 队首的 j 是最优决策点</span><br>            dp[i] = dp[j] + (sum[i] - sum[j]) * (sum[i] - sum[j]) + m;  <span class="hljs-comment">// 计算 dp[i]</span><br>            <span class="hljs-comment">// 下一轮的点(x_j,y_j)(j = i)加入图中，并更新凸壳（因为j &lt; i，所以这里是下一轮）</span><br>            <span class="hljs-comment">// 由于队列中的点都是凸包上的点，所以这里只需要判断队尾的点是否在凸包外即可</span><br>            <span class="hljs-keyword">while</span> (head &lt; tail &amp;&amp; <span class="hljs-built_in">k1_le_k2</span>(q[tail], i, q[tail - <span class="hljs-number">1</span>], q[tail])) tail--;<br>            q[++tail] = i;<br>        &#125;<br>        cout &lt;&lt; dp[n] &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="二分单调栈-1">2. 【二分单调栈】</h4>
<h4 id="动态凸包">3. 【动态凸包】</h4>
<h2 id="d1d-决策单调性优化">3 (1D/1D) 决策单调性优化</h2>
<h3 id="概念-2">概念</h3>
<p>决策单调性适用于 1D/1D 方程，意思是我们计算的 <span class="math inline">\(dp[i]\)</span> 的状态维度是 1 维的 <span class="math inline">\([i]\)</span> ，决策点的维度是 1 维的 <span class="math inline">\([j]\)</span> 。</p>
<hr>
<p><strong>特征状态转移方程</strong></p>
<p><span class="math display">\[
f(i)=\min\limits_{1\le j &lt; i}\{g(j)+w(i,j)\}
\]</span></p>
<p>若 <span class="math inline">\(w(i,j)\)</span> 满足四边形不等式：</p>
<p><span class="math display">\[
\begin{align}
w(a,c)+w(b,d)&amp;\le w(a,d)+w(b,c),\quad a\le b\le c\le d \\
或~w(i,j)+w(i+1,j+1)&amp;\le w(i,j+1)+w(i+1,j),\quad i&lt;i+1\le j
&lt;j+1
\end{align}
\]</span></p>
<p>则可以进行决策单调性优化。</p>
<blockquote>
<p><strong>注1</strong></p>
<p><strong>反</strong>四边形不等式的情况如下</p>
<p><span class="math display">\[
f(i)=\max\limits_{1\le j &lt; i}\{g(j)+w(i,j)\}
\]</span></p>
<p>若 <span class="math inline">\(w(i,j)\)</span>
满足<strong>反</strong>四边形不等式：</p>
<p><span class="math display">\[
\begin{align}
w(a,c)+w(b,d)&amp;\ge w(a,d)+w(b,c),\quad a\le b\le c\le d \\
或~w(i,j)+w(i+1,j+1)&amp;\ge w(i,j+1)+w(i+1,j),\quad i&lt;i+1\le j
&lt;j+1
\end{align}
\]</span></p>
<p>则可以进行决策单调性优化。</p>
<hr>
<p><strong>注2</strong></p>
<p>其实四边形不等式也涵盖了 <span class="math inline">\(g(j)\)</span>
，只不过它在不等式中会被抵消，所以 <span class="math inline">\(w(i,j)\)</span> 起主要作用。</p>
<p><span class="math display">\[
\begin{align}
g(j)+w(i,j)+g(j+1)+w(i+1,j+1)&amp;\le g(j+1)+w(i,j+1)+g(j)+w(i+1,j)\\
w(i,j)+w(i+1,j+1)&amp;\le w(i,j+1)+w(i+1,j)
\end{align}
\]</span></p>
<p>因此考察函数特性时，可以只看 <span class="math inline">\(w(i,j)\)</span> 的性质。</p>
</blockquote>
<h4 id="四边形不等式的性质">四边形不等式的性质</h4>
<p>将四边形不等式移项变形：</p>
<p><span class="math display">\[
\begin{align}
\frac{w(i+\Delta i,j+\Delta j)-w(i,j+\Delta j)}{\Delta i}\le
\frac{w(i+\Delta i,j)-w(i,j)}{\Delta i},~\Delta i\to0,~\Delta
j\to0     \\
即~\lim\limits_{\Delta j\to0}\lim\limits_{\Delta i\to0}\frac{w(i+\Delta
i,j+\Delta j)-w(i,j+\Delta j)- w(i+\Delta i,j)+w(i,j)}{\Delta j\Delta
i}\le0 \tag{1}\\
\frac{w(i+\Delta i,j+\Delta j)-w(i+\Delta i,j)}{\Delta j}\le
\frac{w(i,j+\Delta j)-w(i,j)}{\Delta j}, ~\Delta i\to0,~\Delta
j\to0    \\
即~\lim\limits_{\Delta i\to0}\lim\limits_{\Delta j\to0}\frac{w(i+\Delta
i,j+\Delta j)-w(i+\Delta i,j)- w(i,j+\Delta j)+w(i,j)}{\Delta i\Delta
j}\le0 \tag{2}
\end{align}
\]</span></p>
<p>这个其实就是二元函数的混合偏导数的定义了。进一步改写，令 <span class="math inline">\(x=i,~y=j\)</span> ，并重新整理式子，更加直观：</p>
<p><span class="math display">\[
\frac{\partial^2 w}{\partial y\partial x} \le 0,~
\frac{\partial^2 w}{\partial x\partial y} \le 0\\
\]</span></p>
<p>我超，原来就是混合偏导小于等于零！</p>
<p>我们先来观察有这两个约束条件的连续二元函数的图像具有什么特性：</p>
<blockquote>
<p>实际上，如果是连续曲面，则这两个条件相同，由克莱罗定理可得： <span class="math inline">\(\frac{\partial^2 w}{\partial y\partial
x}=\frac{\partial^2 w}{\partial x\partial y}\)</span> 。</p>
</blockquote>
<h5 id="a.-fracpartial2-wpartial-ypartial-x-le-0">a. <span class="math inline">\(\frac{\partial^2 w}{\partial y\partial x} \le
0\)</span></h5>
<p>从图中可以看到， <span class="math inline">\(0\ge w&#39;(x,y_0) &gt;
w&#39;(x,y_0+\Delta)\)</span> 。 <span class="math inline">\(y\)</span>
越大的 <span class="math inline">\(w(x,y_0)\)</span> 的导数越小。</p>
<p>这里我们求取的是<strong>最小值</strong>。<strong>因此 <span class="math inline">\(y\)</span> 更小的 <span class="math inline">\(w(x,y_0)\)</span> 在后面会被 <span class="math inline">\(y\)</span> 更大的 <span class="math inline">\(w(x,y_0+\Delta)\)</span>
反超</strong>，并保持一小段的最小优势。形成一个类似于下凸壳的东西。</p>
<p><img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/GIF%202024-2-7%2011-58-30-min-1712573757009-6.gif" srcset="/img/loading.gif" lazyload></p>
<p>将不同 <span class="math inline">\(y=j\)</span> 的函数 <span class="math inline">\(w(x=i,y=j)\)</span> 绘制在 <span class="math inline">\(w-x\)</span> 平面上。</p>
<p>我们称呼使得 <span class="math inline">\(f(i)\)</span> 取得最优值的
<span class="math inline">\(w(x=i,y=j)\)</span>
为一个<strong>决策</strong>。由于 DP 计算的是最小值，所以 <span class="math inline">\(f(i)\)</span> 取的是在当前 <span class="math inline">\(x=i\)</span> 下最小费用的决策。</p>
<p>容易发现，在满足四边形不等式的条件下，所取得的决策 <span class="math inline">\(j\)</span> 随 <span class="math inline">\(i\)</span>
的增大而单调不减。故称为<strong>决策单调性</strong>。</p>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7-1712573757010-7.png" srcset="/img/loading.gif" lazyload alt="决策单调性">
<figcaption aria-hidden="true">决策单调性</figcaption>
</figure>
<hr>
<h5 id="b.-fracpartial2-wpartial-xpartial-y-le-0">b. <span class="math inline">\(\frac{\partial^2 w}{\partial x\partial y} \le
0\)</span></h5>
<p>再来看看酷炫的3D动画吧~</p>
<p><img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/GIF%202024-2-7%2015-17-33-min-1712573757010-8.gif" srcset="/img/loading.gif" lazyload></p>
<p>将不同 <span class="math inline">\(x=i\)</span> 的函数 <span class="math inline">\(w(x=i,y=j)\)</span> 绘制在 <span class="math inline">\(w-y\)</span> 平面上。</p>
<p>我们发现，由于 <span class="math inline">\(\frac{\partial^2
w}{\partial x\partial y} \le 0\)</span> ，这些函数的导数随着 <span class="math inline">\(i\)</span> 的增大而递减。</p>
<p>这导致了一个特点：由于这些函数的导数依次减小，所以从起点到最小值点的距离依次增加，最终形成当
<span class="math inline">\(x = i\)</span> 增大时，最小值点对应的 <span class="math inline">\(y=j\)</span> 也随之单调增加。</p>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7_w-y-1712573757010-9.png" srcset="/img/loading.gif" lazyload alt="决策单调性 w-y">
<figcaption aria-hidden="true">决策单调性 <span class="math inline">\(w-y\)</span></figcaption>
</figure>
<blockquote>
<p><strong>注</strong></p>
<p>分别从这两个角度出发来解读，结论都是一样的。</p>
<p>只不过题目并不限制 <span class="math inline">\(j\)</span>
的个数，所以一直围绕着 <span class="math inline">\(i\)</span>
来讨论最优策略。如果限制 <span class="math inline">\(j\)</span>
的大小呢？如果有凸性就可以使用<strong>WQS二分</strong>解除限制。否则分层计算。具体见
<a target="_blank" rel="noopener" href="https://oi-wiki.org/dp/opt/quadrangle/#%E9%99%90%E5%88%B6%E5%8C%BA%E9%97%B4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%83%85%E5%BD%A2">限制区间个数的情形</a>
。</p>
</blockquote>
<blockquote>
<p><strong>值得关注的地方</strong></p>
<ol type="1">
<li><p>四边形不等式并没有限制 <span class="math inline">\(\frac{\partial^2 w}{\partial x^2}\)</span> 和
<span class="math inline">\(\frac{\partial^2 w}{\partial y^2}\)</span>
，所以并不要求是凸函数， <span class="math inline">\(w(x,y=y_0)\)</span>
和 <span class="math inline">\(w(x=x_0,y)\)</span>
也不要求是凸函数。仅仅要求 <span class="math inline">\(w(x,y)\)</span>
满足一部分凸性即可。</p></li>
<li><p>最终还需要考虑 <span class="math inline">\(g(j)\)</span>
对于DP计算的影响。</p>
<p>令 <span class="math inline">\(W(i,j)=g(j)+w(i,j)\)</span>
，将其视为关于 <span class="math inline">\(i\)</span> 的一系列只是常数
<span class="math inline">\(j\)</span> 不同的函数的集合。</p>
<ul>
<li><p>如果 <span class="math inline">\(g(j)\)</span>
<strong>单调不增</strong>：</p>
<p>容易想到，每个决策都将有自己的一席之地。（没有 <span class="math inline">\(g(j)\)</span> 时已经就是这样的格局，再加上递减的
<span class="math inline">\(g(j)\)</span>
，局面更加稳固（说的啥🤣））</p>
<p><img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7-1712573757010-7.png" srcset="/img/loading.gif" lazyload></p></li>
<li><p>如果 <span class="math inline">\(g(j)\)</span> 无明显性质：</p>
<p>可能导致有的决策因为 <span class="math inline">\(g(j)\)</span>
变贵了，被其他策略战胜。类似于斜率优化维护凸壳把点弹走的感觉。</p>
<p><img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7(1)-1712573757010-10.png" srcset="/img/loading.gif" lazyload></p></li>
</ul></li>
<li><p>反四边形不等式的性质和上面的一切完全相反。注意它求的是最大值。</p></li>
</ol>
</blockquote>
<h4 id="结论与拓展">结论与拓展</h4>
<p>对于 <span class="math inline">\(f(i)=\min\limits_{1\le j &lt;
i}\{g(j)+w(i,j)\}\)</span> ，需要 <span class="math inline">\(w(i,j)\)</span> 满足四边形不等式：</p>
<p><span class="math display">\[
w(i,j)+w(i+1,j+1)\le w(i,j+1)+w(i+1,j),\quad i&lt;i+1\le j &lt;j+1
\]</span></p>
<ul>
<li>速记：左中区间 + 右中区间 <span class="math inline">\(\le\)</span>
大区间 + 小区间</li>
</ul>
<hr>
<p>对于 <span class="math inline">\(f(i)=\max\limits_{1\le j &lt;
i}\{g(j)+w(i,j)\}\)</span> ，需要 <span class="math inline">\(w(i,j)\)</span>
满足<strong>反</strong>四边形不等式：</p>
<p><span class="math display">\[
w(i,j)+w(i+1,j+1)\ge w(i,j+1)+w(i+1,j),\quad i&lt;i+1\le j &lt;j+1
\]</span></p>
<ul>
<li>速记：左中区间 + 右中区间 <span class="math inline">\(\ge\)</span>
大区间 + 小区间</li>
</ul>
<hr>
<p>进行决策单调性优化：设 <span class="math inline">\(k(i)\)</span>
为状态 <span class="math inline">\(i\)</span> 的最优决策点（这里的 <span class="math inline">\(k\)</span> 是 <span class="math inline">\(f(i)\)</span> 取得最优情况的 <span class="math inline">\(j\)</span> ，所以用 <span class="math inline">\(k(i)\)</span> 表示），则有：</p>
<p><span class="math display">\[
\begin{align}
k(i-1) \le k(i) \le k(i+1)
\end{align}
\]</span></p>
<mydetails>
<summary>
<summary-title>More</summary-title><summary-subtitle>有关四边形不等式的拓展思考</summary-subtitle>
</summary>
<p><strong>1D/1D 方程</strong></p>
<p><span class="math display">\[
f(i)=\min\limits_{1\le j &lt; i}\{g(j)+w(i,j)\}
\]</span></p>
<ul>
<li><p>对于单调队列优化适用的情况： <span class="math inline">\(w(i,j)=a(i)\)</span> 。</p>
<p>易知其满足四边形恒等式：</p>
<p><span class="math display">\[
\frac{\partial^2 w}{\partial x\partial y}=\frac{\partial ^2 w}{\partial
y\partial x}=0
\]</span></p>
<p><img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/GIF%202024-2-7%2018-12-37-1712573757010-11.gif" srcset="/img/loading.gif" lazyload></p></li>
<li><p>对于斜率优化适用的情况： <span class="math inline">\(w(i,j)=-a(i)d(j)\)</span> 。</p>
<ol type="1">
<li><p><span class="math inline">\(a(i)\)</span> 单调，<span class="math inline">\(d(j)\)</span> 单调，且两者单调性相同</p>
<p><span class="math display">\[
\frac{\partial^2 w}{\partial x\partial y}=\frac{\partial^2 w}{\partial
y\partial x}=-a&#39;(x)b&#39;(y)\le0
\]</span></p>
<p>故满足四边形不等式。所以斜率优化实际上是决策单调性的一个特殊情况。</p>
<p>当然还有 <span class="math inline">\(dp(j)\)</span>
的影响，所以一般不是下图如此完美的凸壳，具体见前文“值得关注的地方”</p>
<p><img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/GIF%202024-2-7%2018-04-20-1712573757010-12.gif" srcset="/img/loading.gif" lazyload></p></li>
</ol></li>
</ul>
<ol start="2" type="1">
<li><p>其他情况</p>
<p>此时<strong>就没四边形不等式什么事了</strong>。我们单纯维护凸壳，每次用
<span class="math inline">\(O(\log n)\)</span>
时间去搜索决策点。这是1D/1D基本上都通用的方法。</p></li>
</ol>
<p></p></mydetails><p></p>
<h3 id="方法一单调队列-二分">(1) 方法一：单调队列 + 二分</h3>
<p>若转移方程是 <span class="math inline">\(f_j+w→f_i\)</span>，那么求
<span class="math inline">\(f_i\)</span> 前就要先求出前面的所有 <span class="math inline">\(f\)</span>，称这个问题为<strong>在线问题</strong>，无法采用方法二的分治做法。此时可以采用顺序计算的单调队列
+ 二分算法。</p>
<p>我们参考斜率优化中用单调队列维护凸壳的策略。不过这里我们构成“凸壳”（不太严谨，或称为最优策略集合）的函数可不是直线了，而是一条条曲线。</p>
<p><img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7(1)-1712573757010-10.png" srcset="/img/loading.gif" lazyload></p>
<p>可是，为什么标题中又还有“二分”呢？</p>
<p>原来，在斜率优化中，由于 <span class="math inline">\(w(i,j)=-a(i)d(j)\)</span>
，我们可以轻松得知凸壳上的最优决策<strong>分界点坐标</strong> <span class="math inline">\((d(j),f(j))\)</span> ，也就是上图中的 <span class="math inline">\(A,F,D\)</span> 这几个点。然后就可以 <span class="math inline">\(O(1)\)</span>
维护单调队列的队首弹出和队尾压入。</p>
<p>但在这里，我们并不知道 <span class="math inline">\(w(i,j)\)</span>
内部的情况，如何确定两个最优决策之间的<strong>分界点</strong>呢？</p>
<p>答案很简单：<strong>二分</strong>。</p>
<ul>
<li><p>当我们取出单调队列里保存的两个最优决策 <span class="math inline">\(j_1&lt;j_2\)</span>
时，它们存在一个<strong>分界点</strong> <span class="math inline">\(i=t\)</span> 。</p></li>
<li><p>在 <span class="math inline">\([0,t)\)</span> 上，决策 <span class="math inline">\(j_1\)</span> 优于决策 <span class="math inline">\(j_2\)</span> ；在 <span class="math inline">\((t,N]\)</span> 上，决策 <span class="math inline">\(j_2\)</span> 优于决策 <span class="math inline">\(j_1\)</span> 。</p></li>
<li><p>只需要在 <span class="math inline">\([j_2,N]\)</span>
上二分搜索这个 <span class="math inline">\(t\)</span> 就可以了。因为
<span class="math inline">\(j&lt;i\)</span> ，所以决策 <span class="math inline">\(j_2\)</span> 的最优区间起点一定在 <span class="math inline">\([i=j_2,N]\)</span> 上</p></li>
</ul>
<p>因此，该方法总时间复杂度为 <span class="math inline">\(O(n\log
n)\)</span> 。</p>
<blockquote>
<p>注意和斜率优化里的二分单调栈区分。它们的二分用途不一样。</p>
<p>建议用一个三元组来描述一个最优策略： <span class="math inline">\(\{i_{left},i_{right},j\}\)</span>
。这样可以避免一点重复计算。不过下面偷懒没搞 XD</p>
</blockquote>
<p><strong>代码示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> dp[MAXN];<br><span class="hljs-type">int</span> q[MAXN], head, tail;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">G</span><span class="hljs-params">(<span class="hljs-type">int</span> j)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">W</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>;<br><span class="hljs-comment">// 计算当x=i，选择决策j时的费用</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">G</span>(j) + <span class="hljs-built_in">W</span>(i, j); &#125;<br><span class="hljs-comment">// 二分找到这两个相邻最优决策的分界点：第一个决策b比决策a优的位置</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">binSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-comment">// 决策b全程劣于决策a，返回一个大于N的数值表示无法取得</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">calc</span>(N, a) &lt; <span class="hljs-built_in">calc</span>(N, b)) <span class="hljs-keyword">return</span> N + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> l = b, r = N, mid, ans = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>        mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">calc</span>(mid, b) &gt; <span class="hljs-built_in">calc</span>(mid, a)) l = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>， ans = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, q[head = tail = <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        <span class="hljs-comment">// 弹出当前最优决策（囊括了i）之前的决策，那些用不上了</span><br>        <span class="hljs-keyword">while</span> (head &lt; tail &amp;&amp; <span class="hljs-built_in">binSearch</span>(q[head],q[head+<span class="hljs-number">1</span>]) &lt;= i) head++;  <br>        dp[i] = <span class="hljs-built_in">calc</span>(i, q[head]);<br>        <span class="hljs-comment">// 计算决策j=i，如果它比队尾的好，就把队尾弹走</span><br>        <span class="hljs-keyword">while</span> (head &lt; tail &amp;&amp; <span class="hljs-built_in">binSearch</span>(q[tail],i) &lt;= <span class="hljs-built_in">binSearch</span>(q[tail<span class="hljs-number">-1</span>],q[tail])) tail--;<br>        q[++tail] = i;  <span class="hljs-comment">// 决策j=i存入队尾</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法二分治法">(2) 方法二：分治法</h3>
<p>若转移方程是 <span class="math inline">\(g+w→f\)</span>
的转移，即转移是由一个完全已知的函数或是 DP
数组的上一层得来的，将这种决策单调性视作“离线的”。此时不依赖前面的 <span class="math inline">\(f_{i-1}\)</span> 来计算 <span class="math inline">\(f_i\)</span> ，就可以不顺序计算 <span class="math inline">\(f_i\)</span>
了，能够采用分治的方法，编码更简单。</p>
<p>为了求解所有状态 <span class="math inline">\(1 \leq i \leq n\)</span>
的最优决策点 <span class="math inline">\(j=\mathop{\mathrm{opt}}(i)\)</span>，依据决策单调性可采取分治思想。</p>
<p><strong>算法步骤</strong></p>
<ol type="1">
<li>初始化：首先暴力遍历 <span class="math inline">\(j\in
[1,n/2)\)</span> 计算 <span class="math inline">\(\mathop{\mathrm{opt}}(n/2)\)</span>，作为分治的中心点。</li>
<li>分治求解：接下来，算法分别计算两个区间 <span class="math inline">\([1,n/2)\)</span> 和 <span class="math inline">\((n/2, n]\)</span> 上的 <span class="math inline">\(\mathop{\mathrm{opt}}(i)\)</span>。
<ul>
<li>对于前半段 <span class="math inline">\([1,n/2)\)</span> ，最优决策点
<span class="math inline">\(\mathop{\mathrm{opt}}(i)\)</span> 必然位于
<span class="math inline">\(1\)</span> 和 <span class="math inline">\(\mathop{\mathrm{opt}}(n/2)\)</span>
之间（含端点）。</li>
<li>对于后半段 <span class="math inline">\((n/2, n]\)</span>
，最优决策点 <span class="math inline">\(\mathop{\mathrm{opt}}(i)\)</span> 必然位于 <span class="math inline">\(\mathop{\mathrm{opt}}(n/2)\)</span> 和 <span class="math inline">\(\mathop{\mathrm{opt}}(n)\)</span>
之间（含端点）。</li>
</ul></li>
<li>递归处理：对于每个子区间，使用相同的方法进行处理，直至计算出每个问题的最优决策点。</li>
</ol>
<p><strong>代码示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 计算dp[i]选择决策j时的费用</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>;<br><span class="hljs-comment">// [l,r]是状态i的区间，[k_l,k_r]是决策点j的区间</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k_l, <span class="hljs-type">int</span> k_r)</span> </span>&#123;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>, k = k_l;<br>    <span class="hljs-comment">// 求状态f[mid]的最优决策点（费用最少）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = k_l; j &lt;= <span class="hljs-built_in">min</span>(k_r, mid - <span class="hljs-number">1</span>); j++) <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">calc</span>(mid, j) &lt; <span class="hljs-built_in">calc</span>(mid, k)) k = j;<br>    dp[mid] = <span class="hljs-built_in">calc</span>(mid, k);<br>    <span class="hljs-comment">// 根据决策单调性得出左右两部分的决策区间，递归处理</span><br>    <span class="hljs-keyword">if</span> (l &lt; mid) <span class="hljs-built_in">dfs</span>(l, mid - <span class="hljs-number">1</span>, k_l, k);<br>    <span class="hljs-keyword">if</span> (r &gt; mid) <span class="hljs-built_in">dfs</span>(mid + <span class="hljs-number">1</span>, r, k, k_r);<br>&#125;<br><span class="hljs-comment">// ans = dp[n]</span><br></code></pre></td></tr></table></figure>
<p><strong>算法复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：通过记录搜索的上下边界，算法的时间复杂度可以控制在
<span class="math inline">\(O(n\log n)\)</span>。</p>
<ul>
<li>递归树的深度为 <span class="math inline">\(O(\log
n)\)</span>，因为每次问题规模都减半。</li>
<li>在每一层递归中，单个决策点最多被计算两次。因此，总的计算次数为 <span class="math inline">\(O(n\log n)\)</span>。</li>
</ul></li>
<li><p>空间复杂度：算法的空间复杂度主要由递归栈空间决定，也是 <span class="math inline">\(O(\log n)\)</span>。</p></li>
</ul>
<p><strong>分治法相比单调队列的优点</strong></p>
<ul>
<li><p>若 <span class="math inline">\(w(i,j)\)</span> 不能够 <span class="math inline">\(O(1)\)</span> 计算，但是可以从 <span class="math inline">\(w(i\pm 1,j\pm 1)\)</span> 来 <span class="math inline">\(O(1)\)</span> 递推</p>
<p>此时分治法能够以均摊 <span class="math inline">\(O(1)\)</span>
的速度计算 <span class="math inline">\(w(i,j)\)</span> 。因为
<code>for (int j=kl;j&lt;=min(kr,mid-1);j++)</code> 计算 <span class="math inline">\(w(i,j)\)</span> 的区间是顺序扩大的。</p>
<p>而单调队列在 <span class="math inline">\([b,N]\)</span>
之间二分，计算 <span class="math inline">\(w(i,j)\)</span>
的区间是乱跳的，不能利用递推优化。</p>
<p>例题：<a href="#2.%20%5BCF868F%5D%20Yet%20Another%20Minimization%20Problem">2.
[CF868F] Yet Another Minimization Problem</a></p></li>
</ul>
<h3 id="方法三smawk-算法">(3) 方法三：SMAWK 算法</h3>
<p>有待后续填坑~</p>
<p>https://www.cnblogs.com/p-b-p-b/p/15054179.html</p>
<p>https://www.luogu.com.cn/blog/FunnyCreature/solution-cf1423m</p>
<p>https://www.cnblogs.com/juju527/p/17376826.html</p>
<p><span class="math inline">\(O(n+m(1+\max(\log \dfrac n
m,0)))\)</span></p>
<p>https://github.com/Itst00/APIO2021-monge/tree/main APIO2021-monge
好东西！！！</p>
<h3 id="方法四wilber-算法">(4) 方法四：Wilber 算法</h3>
<p>有待后续填坑~</p>
<p>https://www.cnblogs.com/p-b-p-b/p/15054179.html</p>
<p><span class="math inline">\(O(n)\)</span></p>
<h3 id="方法五eppstein-算法">(5) 方法五：Eppstein 算法</h3>
<p>有待后续填坑~</p>
<p>https://www.cnblogs.com/p-b-p-b/p/15054179.html</p>
<p><span class="math inline">\(O(n)\)</span></p>
<h3 id="决策单调性模板题">决策单调性模板题</h3>
<h4 id="单调队列二分p1912-noi2009-诗人小g">1. 【单调队列二分】<a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P1912">P1912 NOI2009
诗人小G</a></h4>
<p><strong>题意概述</strong></p>
<p>对一首诗进行排版，诗句长度各异，一行可放下多句，每句用空格隔开。设【不协调度】为每行的实际长度与行标准长度的差值绝对值的P次方之和，要求使得【不协调度】尽量小。句子间用空格隔开，句子顺序不变，不可拆分。</p>
<p>给定诗句数 <span class="math inline">\(N\)</span> 、行标准长度 <span class="math inline">\(L\)</span> 、<span class="math inline">\(P\)</span>
值，输出最小不协调度下的排版，若最小不协调度超过 <span class="math inline">\(10^{18}\)</span> 则输出"Too hard to arrange"。</p>
<p><strong>决策单调性的二分队列解题思路</strong></p>
<p>设 <span class="math inline">\(dp[i]\)</span> 为前 <span class="math inline">\(i\)</span> 个句子的最小不协调度。每句诗的长度为
<span class="math inline">\(a[i]\)</span> ， <span class="math inline">\(sum[i]\)</span> 为前 <span class="math inline">\(i\)</span> 句诗的总长度。则：</p>
<p><span class="math display">\[
dp[i]=\min\limits_{j\in [0,i)}\{dp[j]+|sum[i]-sum[j]+(i-j-1)-L|^P\}
\]</span></p>
<p>意思是将第 <span class="math inline">\([j+1,i]\)</span>
句作为最后一行，前面的句子最小不协调度为 <span class="math inline">\(dp[j]\)</span> 。这里 <span class="math inline">\(P\)</span> 次数太大不能斜率优化，则尝试证明 <span class="math inline">\(w(i,j)=|sum[i]-sum[j]+(i-j-1)-L|^P\)</span>
满足四边形不等式。</p>
<p>有点不好证，通常可以打表或直接写一下决策单调性看看。</p>
<mydetails>
<summary>
<summary-title>Proof</summary-title><summary-subtitle>详细证明</summary-subtitle>
</summary>
<p>证明：</p>
<p><span class="math display">\[
\begin{align}
w(i,j)+w(i+1,j+1) &amp;\le w(i+1,j)+w(i,j+1),~j&lt;i\\
\therefore w(i,j)-w(i+1,j) &amp;\le w(i,j+1)-w(i+1,j+1)
\end{align}
\]</span></p>
<p>设 <span class="math inline">\(u=(sum[i]+i)-(sum[j]+j)-(L+1),~v=(sum[i]+i)-(sum[j+1]+j+1)-(L+1)\)</span>
，则：</p>
<p><span class="math display">\[
|v|^P-|v+(a[i+1]|+1)|^P \geq |u|^P -|u+(a[i+1]+1)|^P,~v\le u
\]</span></p>
<p>设 <span class="math inline">\(h(x)=|x|^P-|x+c|^P, c&gt;0\)</span>
，则只需证明它单调递减即可：</p>
<p><span class="math display">\[
\begin{align}
&amp;分类讨论:\\
①&amp;~~x\in [0,+\infty)\\
\therefore&amp;~~h(x)=x^P-(x+c)^P\\
\therefore&amp;~~h&#39;(x)=Px^{P-1}-P(x+c)^{P-1}&lt; 0\\
\\
②&amp;~~x\in [-c,0) \\
\therefore&amp;~~h(x)=(-x)^P-(x+c)^P\\
\therefore&amp;~~h&#39;(x)=-P(-x)^{P-1}-P(x+c)^{P-1}\\
若&amp;~P~为奇数：\\
&amp;~~h&#39;(x)=-Px^{P-1}-P(x+c)^{P-1}&lt;0\\
若&amp;~P~为偶数：\\
&amp;~~h&#39;(x)=Px^{P-1}-P(x+c)^{P-1}&lt;0\\
\\
③&amp;~~x\in (-\infty,-c)\\
\therefore&amp;~~h(x)=(-x)^P-(-x-c)^P\\
\therefore&amp;~~h&#39;(x)=-P(-x)^{P-1}-P(-x-c)^{P-1}\\
若&amp;~P~为奇数：\\
&amp;~~h&#39;(x)=-Px^{P-1}-P(x+c)^{P-1}&lt;0\\
若&amp;~P~为偶数：\\
&amp;~~h&#39;(x)=Px^{P-1}+P(x+c)^{P-1}&lt;0\\
\\
综&amp;上所述，h&#39;(x)&lt;0。
\end{align}
\]</span></p>
<p></p></mydetails><p></p>
<p>证完后就直接套模板了。单调队列那里和斜率优化的很像，只不过维护的不是斜率，而是决策函数
<span class="math inline">\(w(x,y=j)\)</span>
。维护凸壳时用二分来查找分界点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 100005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXL 35</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPS 1e-9</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;            <span class="hljs-comment">// 2^63 - 1 = 9.22e18</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;  <span class="hljs-comment">// 2^64 - 1 = 1.84e18</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">double</span> ld;          <span class="hljs-comment">// 1.18e4932</span><br><span class="hljs-type">char</span> sen[MAXN][MAXL];<br><span class="hljs-type">int</span> a[MAXN], sum[MAXN];<br><span class="hljs-type">int</span> N, L, P;<br>ld dp[MAXN];<br><span class="hljs-type">int</span> from[MAXN], cnt[MAXN], stk[MAXN], stkTop;<br><span class="hljs-type">int</span> q[MAXN], head, tail;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ld <span class="hljs-title">fastPow</span><span class="hljs-params">(ld bottom, <span class="hljs-type">int</span> hat)</span> </span>&#123;<br>    ld res = <span class="hljs-number">1.0l</span>;<br>    <span class="hljs-keyword">while</span> (hat) &#123;<br>        <span class="hljs-keyword">if</span> (hat &amp; <span class="hljs-number">1</span>) res *= bottom;<br>        bottom *= bottom;<br>        hat &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">// 计算当x=i，选择决策j时的费用</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ld <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>    <span class="hljs-type">int</span> w = <span class="hljs-built_in">abs</span>(sum[i] - sum[j] + i - j - <span class="hljs-number">1</span> - L);<br>    <span class="hljs-keyword">return</span> dp[j] + <span class="hljs-built_in">fastPow</span>(w, P);<br>&#125;<br><span class="hljs-comment">// 二分找到这两个相邻最优决策的分界点：第一个决策b比决策a优的位置</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">binSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-comment">// 决策b全程劣于决策a，返回一个大于N的数值表示无法取得</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">calc</span>(N, a) &lt; <span class="hljs-built_in">calc</span>(N, b)) <span class="hljs-keyword">return</span> N + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> l = b, r = N, mid, ans = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>        mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">calc</span>(mid, b) &gt; <span class="hljs-built_in">calc</span>(mid, a)) l = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>， ans = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">fill</span>(dp, dp + N + <span class="hljs-number">1</span>, LDBL_MAX);<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, q[head = tail = <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        <span class="hljs-comment">// 弹出当前最优决策（囊括了i）之前的决策，那些用不上了</span><br>        <span class="hljs-keyword">while</span> (head &lt; tail &amp;&amp; <span class="hljs-built_in">binSearch</span>(q[head],q[head+<span class="hljs-number">1</span>]) &lt;= i) head++;  <br>        dp[i] = <span class="hljs-built_in">calc</span>(i, q[head]);<br>        from[i] = q[head];  <span class="hljs-comment">// 记录从哪里转移过来，用于输出结果</span><br>        cnt[i] = i - q[head];<br>        <span class="hljs-comment">// 计算决策j=i，如果它比队尾的好，就把队尾弹走</span><br>        <span class="hljs-keyword">while</span> (head &lt; tail &amp;&amp; <span class="hljs-built_in">binSearch</span>(q[tail],i) &lt;= <span class="hljs-built_in">binSearch</span>(q[tail<span class="hljs-number">-1</span>],q[tail])) tail--;<br>        q[++tail] = i;  <span class="hljs-comment">// 决策j=i存入队尾</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (dp[N] &gt; <span class="hljs-number">1e18</span>l) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Too hard to arrange\n--------------------\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    cout &lt;&lt; (ull)dp[N] &lt;&lt; endl;<br>    stkTop = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = N; i; i = from[i]) stk[++stkTop] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = stk[stkTop--], rp = <span class="hljs-number">1</span>;;) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = rp; j &lt; rp + cnt[i]; j++) &#123;<br>            cout &lt;&lt; sen[j];<br>            <span class="hljs-keyword">if</span> (j &lt; rp + cnt[i] - <span class="hljs-number">1</span>) cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<br>        rp += cnt[i];<br>        <span class="hljs-keyword">if</span> (stkTop) i = stk[stkTop--];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------\n&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> t; cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        cin &gt;&gt; N &gt;&gt; L &gt;&gt; P;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>            cin &gt;&gt; sen[i];<br>            a[i] = <span class="hljs-built_in">strlen</span>(sen[i]);<br>            sum[i] = sum[i - <span class="hljs-number">1</span>] + a[i];<br>        &#125;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="分治法cf868f-yet-another-minimization-problem">2. 【分治法】<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF868F">CF868F Yet Another
Minimization Problem</a></h4>
<p><strong>题意概述</strong></p>
<p>给定一个序列 a，要把它分成 k
个子段。每个子段的费用是其中相同元素的对数。求所有子段的费用之和的最小值。</p>
<p><strong>单调决策性的分治法解题思路</strong></p>
<ol type="1">
<li><p>确定状态转移方程</p>
<p>设 <span class="math inline">\(dp[i][k]\)</span> 为前 <span class="math inline">\(i\)</span> 个数分成 <span class="math inline">\(k\)</span> 个子段的最小费用之和。则：</p>
<p><span class="math display">\[
dp[i][k] = min(dp[j][k-1] + cost(j+1, i))
\]</span></p>
<p>其中 <span class="math inline">\(cost(j+1, i)\)</span> 为区间 <span class="math inline">\([j+1,i]\)</span> 的费用。 <span class="math inline">\(dp[j][k-1]\)</span> 可以看作 <span class="math inline">\(g(j)\)</span> ， <span class="math inline">\(cost(j+1, i)\)</span> 可以看作 <span class="math inline">\(w(i,j)\)</span> 。</p></li>
<li><p>证明 <span class="math inline">\(w(i,j)\)</span>
满足四边形不等式</p>
<p>即证明 <span class="math inline">\(w(i,j) + w(i+1,j+1) \le w(i+1,j) +
w(i,j+1)\)</span> 。 考虑 <span class="math inline">\(a[i]\)</span> 和
<span class="math inline">\(a[j]\)</span> 的情况：</p>
<ul>
<li><p>若 <span class="math inline">\(a[i]=a[j]\)</span> 且区间 <span class="math inline">\([j+1,i]\)</span> 内有和它们相等的数，则 <span class="math inline">\(w(i+1,j) + w(i,j+1)\)</span> 会比 <span class="math inline">\(w(i,j)+w(i+1,j+1)\)</span> 多了一个 <span class="math inline">\(a[i]\)</span> 和 <span class="math inline">\(a[j]\)</span> 的对数。</p></li>
<li><p>其他情况，等式成立。</p></li>
</ul>
<p>因此， <span class="math inline">\(w(i,j)\)</span>
满足四边形不等式。</p></li>
<li><p>决策单调性实现算法</p>
<p>由于 <span class="math inline">\(w(i,j)\)</span> 并不是 <span class="math inline">\(O(1)\)</span>
计算的，所以用单调队列就比较慢了。但是注意到 <span class="math inline">\(w(i,j)\)</span> 可以由 <span class="math inline">\(w(i+1,j)\)</span> 和 <span class="math inline">\(w(i,j+1)\)</span>
递推得到。因此采用分治法。</p></li>
<li><p>区间 <span class="math inline">\([j+1,i]\)</span> 的费用计算</p>
<p>参考离线莫队里面用左右两个指针表示当前计算的区间值，并暴力移动来维护区间的费用。因为我们是分治法，所以在计算mid的最优决策时左右指针依次移动一步即可，是
<span class="math inline">\(O(1)\)</span>
的。这就是分治法的优势。</p></li>
<li><p>注意要开 long long</p></li>
</ol>
<p>时间复杂度大概是 <span class="math inline">\(O(kn\log n)\)</span>
。这里的受限制参数 <span class="math inline">\(k\)</span>
比较小，虽然有凸性但WQS二分区间太大，反而不如直接遍历来得快。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 100005</span><br><span class="hljs-type">int</span> N, K, a[MAXN], cnt[MAXN], wl = <span class="hljs-number">1</span>, wr;<br>ll dp[MAXN][<span class="hljs-number">2</span>], now = <span class="hljs-number">0</span>, pre = <span class="hljs-number">1</span>, w;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">cost</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (wl &gt; l) wl--, w += cnt[a[wl]]++;<br>    <span class="hljs-keyword">while</span> (wr &lt; r) wr++, w += cnt[a[wr]]++;<br>    <span class="hljs-keyword">while</span> (wl &lt; l) w -= --cnt[a[wl]], wl++;<br>    <span class="hljs-keyword">while</span> (wr &gt; r) w -= --cnt[a[wr]], wr--;<br>    <span class="hljs-keyword">return</span> w;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> dp[j][pre] + <span class="hljs-built_in">cost</span>(j+<span class="hljs-number">1</span>, i);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> kl, <span class="hljs-type">int</span> kr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>, k = kl;<br>    ll kval = <span class="hljs-built_in">calc</span>(mid, k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = kl; j &lt;= <span class="hljs-built_in">min</span>(kr, mid); j++) &#123;<br>        ll tmp = <span class="hljs-built_in">calc</span>(mid, j);<br>        <span class="hljs-keyword">if</span> (tmp &lt; kval) k = j, kval = tmp;<br>    &#125;<br>    dp[mid][now] = kval;<br>    <span class="hljs-keyword">if</span> (l &lt; mid) <span class="hljs-built_in">divide</span>(l, mid - <span class="hljs-number">1</span>, kl, k);<br>    <span class="hljs-keyword">if</span> (r &gt; mid) <span class="hljs-built_in">divide</span>(mid + <span class="hljs-number">1</span>, r, k, kr);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; N &gt;&gt; K;<br>    wr = N;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        cin &gt;&gt; a[i];<br>        dp[i][now] = (w += cnt[a[i]]++);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= K; i++) &#123;<br>        <span class="hljs-built_in">swap</span>(now, pre);<br>        <span class="hljs-built_in">divide</span>(<span class="hljs-number">1</span>, N, <span class="hljs-number">1</span>, N);<br>    &#125;<br>    cout &lt;&lt; dp[N][now];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="分治法poi2011-lightning-conductor">3. 【分治法】<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3515">POI2011 Lightning
Conductor</a></h4>
<p><strong>题目大意</strong></p>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(\{a_n\}\)</span>，对于每个 <span class="math inline">\(i\in [1,n]\)</span> ，求出一个最小的非负整数 <span class="math inline">\(p\)</span> ，使得 <span class="math inline">\(\forall j\in[1,n]\)</span>，都有 <span class="math inline">\(a_j\le a_i+p-\sqrt{|i-j|}\)</span></p>
<p><span class="math inline">\(1 \le n \le 5\times
10^{5}\)</span>，<span class="math inline">\(0 \le a_i \le
10^{9}\)</span> 。</p>
<p><strong>单调决策性的二分队列解题思路</strong></p>
<p>设 <span class="math inline">\(dp[i]\)</span> 为第 <span class="math inline">\(i\)</span> 个数的最小 <span class="math inline">\(p\)</span> 值（注意不是 <span class="math inline">\(\min\)</span> ，我们要看 <span class="math inline">\(p\)</span> 的式子，那个计算是 <span class="math inline">\(\max\)</span> 计算）。则：</p>
<p><span class="math display">\[
\begin{align}
p_i &amp;= \max\limits_{j\in [0,i)}\{a_j-a_i+\sqrt{|i-j|}\}\\
p_i &amp;= \max\limits_{j\in [0,i)}\{a_j+\sqrt{|i-j|}-a_i\}\\
\text{Let } w(i,j) &amp;= \sqrt{|i-j|}-a_i,~g_j=a_j\\
\therefore f_i &amp;= \max\limits_{j\in [0,i)}\{g_j+w(i,j)\}
\end{align}
\]</span></p>
<p>小证一下 <span class="math inline">\(w(i,j)\)</span>
满足四边形不等式：</p>
<p><span class="math display">\[
\begin{align}
\text{TBD: }&amp;~w(i,j)+w(i+1,j+1) \le w(i+1,j)+w(i,j+1)\\
\text{Namely: }&amp;~\sqrt{|i-j|}+\sqrt{|i+1-j-1|} \le
\sqrt{|i+1-j|}+\sqrt{|i-j+1|}\\
\text{That is: }&amp;~2\sqrt{|i-j|} \le 2\sqrt{|i-j+1|}\\
\end{align}
\]</span></p>
<p>显然成立。直接用分治法套模板即可。</p>
<p>注意这里由于绝对值的存在， <span class="math inline">\(j\)</span>
是会大于 <span class="math inline">\(i\)</span>
的。可以看作两个不同的问题。我们将序列反转，做第二遍分治，取两次分治的最大值即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, a[<span class="hljs-number">500005</span>];<br><span class="hljs-type">double</span> p[<span class="hljs-number">500005</span>];<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> calc(i, j) (a[j] + sqrt(abs(i - j)) - a[i])</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> kl, <span class="hljs-type">int</span> kr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>, k = kl;<br>    <span class="hljs-type">double</span> kval = <span class="hljs-built_in">calc</span>(mid, kl), tmp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = kl; j &lt;= <span class="hljs-built_in">min</span>(kr, mid); j++) &#123;<span class="hljs-comment">// 这里j=mid可以，此时为tmp=0被排除，也可以改为mid-1</span><br>        tmp = <span class="hljs-built_in">calc</span>(mid, j);<br>        <span class="hljs-keyword">if</span> (tmp &gt; kval) k = j, kval = tmp; <span class="hljs-comment">// 取最大的p</span><br>    &#125;   <br>    p[mid] = <span class="hljs-built_in">max</span>(p[mid], kval);    <span class="hljs-comment">// 两次，取最大的</span><br>    <span class="hljs-keyword">if</span> (l &lt; mid) <span class="hljs-built_in">divide</span>(l, mid - <span class="hljs-number">1</span>, kl, k);<br>    <span class="hljs-keyword">if</span> (mid &lt; r) <span class="hljs-built_in">divide</span>(mid + <span class="hljs-number">1</span>, r, k, kr);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];<br>    <span class="hljs-built_in">divide</span>(<span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>, n);<br>    <span class="hljs-built_in">reverse</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>); <span class="hljs-comment">// 由于只处理了 j &lt;= i 的决策，还要倒过来在算一遍</span><br>    <span class="hljs-built_in">reverse</span>(p + <span class="hljs-number">1</span>, p + n + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">divide</span>(<span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) cout &lt;&lt; (<span class="hljs-type">int</span>)<span class="hljs-built_in">ceil</span>(p[i]) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// 小数向上取整</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="决策单调性练习题">决策单调性练习题</h3>
<p><strong>单调队列二分</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1973">P1973 NOI2011
Noi嘉年华</a></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3724">P3724
[AHOI2017/HNOI2017] 大佬</a></p>
<p><strong>分治</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5504">P5504 [JSOI2011]
柠檬</a></p>
<h2 id="d1d-四边形不等式优化">4 (2D/1D) 四边形不等式优化</h2>
<h4 id="概念-3">概念</h4>
<p>这里的四边形不等式优化指的是<strong>区间决策单调性</strong>优化。</p>
<p>四边形不等式常用于优化 2D/1D 方程，意思是我们计算的 <span class="math inline">\(dp[i][j]\)</span> 的状态维度是 2 维的 <span class="math inline">\([i][j]\)</span> ，决策点的维度是 1 维的 <span class="math inline">\([k]\)</span> 。</p>
<p><strong>四边形不等式特征状态方程</strong>：</p>
<p><span class="math display">\[
\begin{align}
dp[i][j] &amp;= \min\{dp[i][k]+dp[k+1][j]+w[i][j]\},\quad k \in [i,j-1]
\\
&amp;=\min\{dp[i][k]+dp[k+1][j]\}+w[i][j]
\end{align}
\]</span></p>
<p><strong>四边形不等式</strong>：</p>
<p><span class="math display">\[
\begin{align}
w(a,c)+w(b,d)&amp;\le w(a,d) + w(b,c),\quad a\le b\le c\le d\\
或者~w(i,j)+w(i+1,j+1)&amp;\le w(i,j+1) + w(i+1,j),\quad i&lt;i+1\le j
&lt;j+1
\end{align}
\]</span></p>
<ul>
<li>速记：<strong>左中区间 + 右中区间 <span class="math inline">\(\le\)</span> 大区间 + 小区间</strong></li>
</ul>
<p><strong>单调性</strong>：</p>
<p><span class="math display">\[
对任意~a\le b\le c\le d,~有~w(b,c) \le w(a,d). \\
或者~w(i+1,j) \le w(i,j+1)
\]</span></p>
<ul>
<li>速记：<strong>小区间 <span class="math inline">\(\le\)</span>
大区间</strong>，类似于一维的单调递增</li>
</ul>
<p><strong>四边形不等式定理</strong>：如果 <span class="math inline">\(w(i,j)\)</span>
满足<strong>四边形不等式</strong>和<strong>单调性</strong>，则用DP计算
<span class="math inline">\(dp[][]\)</span> 的时间复杂度为 <span class="math inline">\(O(n^2)\)</span></p>
<p><strong>引理 1</strong>：如果 <span class="math inline">\(w(i,j)\)</span> 满足四边形不等式和单调性，则 <span class="math inline">\(dp[i][j] =
\min(dp[i][k]+dp[k+1][j]+w[i][j])\)</span>
<strong>也满足四边形不等式</strong>。</p>
<p><strong>引理 2</strong>：记 <span class="math inline">\(s[i][j]=k\)</span> 为 <span class="math inline">\(dp[i][j]\)</span> 取得最小值时的 <span class="math inline">\(k\)</span>，如果 <span class="math inline">\(dp[i][j]\)</span> 满足四边形不等式，则有：</p>
<p><span class="math display">\[
s[i][j-1]\le k \le s[i+1][j]
\]</span></p>
<ul>
<li>速记：<strong>左中区间 <span class="math inline">\(\le\)</span>
大区间 <span class="math inline">\(\le\)</span> 右中区间</strong></li>
</ul>
<hr>
<p><strong>反四边形不等式特征状态方程（min变为max）</strong>：</p>
<p><span class="math display">\[
\begin{align}
dp[i][j] &amp;= \max\{dp[i][k]+dp[k+1][j]+w[i][j]\},\quad k \in [i,j-1]
\\
&amp;=\max\{dp[i][k]+dp[k+1][j]\}+w[i][j]
\end{align}
\]</span></p>
<p><strong>反四边形不等式（<span class="math inline">\(\le\)</span> 变为
<span class="math inline">\(\ge\)</span>）</strong>：</p>
<p><span class="math display">\[
\begin{align}
w(a,c)+w(b,d)&amp;\ge w(a,d) + w(b,c),\quad a\le b\le c\le d\\
或者~w(i,j)+w(i+1,j+1)&amp;\ge w(i,j+1) + w(i+1,j),\quad i&lt;i+1\le j
&lt;j+1
\end{align}
\]</span></p>
<ul>
<li>速记：<strong>左中区间+右中区间 <span class="math inline">\(\ge\)</span> 大区间+小区间</strong></li>
</ul>
<p><strong>单调性（<span class="math inline">\(\le\)</span> 变为 <span class="math inline">\(\ge\)</span>）</strong>：</p>
<p><span class="math display">\[
对任意~a\le b\le c\le d,~有~w(b,c) \ge w(a,d).
\]</span></p>
<ul>
<li>速记：<strong>小区间 <span class="math inline">\(\ge\)</span>
大区间</strong>，类似于一维的单调递减</li>
</ul>
<p><strong>反四边形不等式定理</strong>：如果 <span class="math inline">\(w(i,j)\)</span>
满足<strong>反四边形不等式</strong>和<strong>单调性</strong>，则用DP计算
<span class="math inline">\(dp[][]\)</span> 的时间复杂度为 <span class="math inline">\(O(n^2)\)</span></p>
<p><strong>引理 3</strong>：如果 <span class="math inline">\(w(i,j)\)</span> 满足反四边形不等式和单调性，则
<span class="math inline">\(dp[i][j] =
\max(dp[i][k]+dp[k+1][j]+w[i][j])\)</span>
<strong>也满足反四边形不等式</strong>。</p>
<p><strong>引理 4</strong>：记 <span class="math inline">\(s[i][j]=k\)</span> 为 <span class="math inline">\(dp[i][j]\)</span> 取得最大值时的 <span class="math inline">\(k\)</span>，如果 <span class="math inline">\(dp[i][j]\)</span>
满足反四边形不等式，则有（和前面的相同）：</p>
<p><span class="math display">\[
s[i][j-1]\le k \le s[i+1][j]
\]</span></p>
<ul>
<li>速记：<strong>左中区间 <span class="math inline">\(\le\)</span>
大区间 <span class="math inline">\(\le\)</span> 右中区间</strong></li>
</ul>
<hr>
<h4 id="区间决策单调性模板题">区间决策单调性模板题</h4>
<p>石子合并问题</p>
<p><span class="math inline">\(\texttt{Description}\)</span></p>
<p>有 n
堆石子排成一排，每堆石子有一定的数量。每次可以将两堆相邻的石子堆合并，合并后的石子堆的数量为两堆石子堆的数量之和。合并的费用为两堆石子堆的数量之和。经过n-1次合并后，所有的石子堆都被合并成了一堆，求出总费用的最小值。</p>
<p><span class="math inline">\(\texttt{Input}\)</span></p>
<p>第一行：n，表示石子堆数目； 第二行：n个数，表示每堆石子的数量</p>
<p><span class="math inline">\(\texttt{Output}\)</span></p>
<p>输出总费用的最小值 (附加：求最大值)</p>
<p><span class="math inline">\(\texttt{Hint}\)</span></p>
<blockquote>
<p>合并过程：(2,4,5) -&gt; (6,5) -&gt; (11) 总费用为17</p>
</blockquote>
<p><strong>题解</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1002</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> w[N];      <span class="hljs-comment">// 前缀和维护[i,j]中的所有石子数量</span><br><span class="hljs-type">int</span> dp[N][N];  <span class="hljs-comment">// dp[i][j] 表示合并[i,j]中石子的最优值</span><br><span class="hljs-type">int</span> s[N][N];   <span class="hljs-comment">// s[i][j] 表示最佳分割点</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sum(i, j) w[j] - w[i - 1]</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, tmp; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; tmp;<br>        w[i] = w[i - <span class="hljs-number">1</span>] + tmp;<br>    &#125;<br><br>    <span class="hljs-comment">// 求最小值</span><br>    <span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        dp[i][i] = <span class="hljs-number">0</span>;<br>        s[i][i] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; len++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = i + len - <span class="hljs-number">1</span>; j &lt;= n; i++, j++) &#123;<br>            <span class="hljs-comment">// 此处用四边形不等式优化，因为sum[i,j]满足四边形恒等式和单调递增（单调递增只是比喻的说法）</span><br>            <span class="hljs-comment">// 原本的 for (int k = i; k &lt; j; k++) 优化为下面的</span><br>            <span class="hljs-comment">// 注意右侧区间端点是 &lt;=</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = s[i][j - <span class="hljs-number">1</span>]; k &lt;= s[i + <span class="hljs-number">1</span>][j]; k++) &#123;<br>                <span class="hljs-keyword">if</span> (dp[i][j] &gt; dp[i][k] + dp[k + <span class="hljs-number">1</span>][j] + <span class="hljs-built_in">sum</span>(i, j)) &#123;<br>                    dp[i][j] = dp[i][k] + dp[k + <span class="hljs-number">1</span>][j] + <span class="hljs-built_in">sum</span>(i, j);<br>                    s[i][j] = k;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[<span class="hljs-number">1</span>][n] &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 下面求最大值，这个要改一下初始化</span><br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        dp[i][i] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; len++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = i + len - <span class="hljs-number">1</span>; j &lt;= n; i++, j++) &#123;<br>            <span class="hljs-comment">// 此处不可以用反四边形不等式优化，因为sum[i,j]不满足单调递减（单调递减只是比喻的说法）</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i; k &lt; j; k++) &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i][k] + dp[k + <span class="hljs-number">1</span>][j] + <span class="hljs-built_in">sum</span>(i, j));<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[<span class="hljs-number">1</span>][n] &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="d1d-wqs带权二分优化">5 (2D/1D) WQS带权二分优化</h2>
<p><strong>特征状态方程</strong>：</p>
<p><span class="math display">\[
\begin{align}
&amp;f(i,j)=\min/\max\{g(i,k)+w(i,j)\},\quad j \in [1,i],\quad
w(i,j)~无明显性质 \\\\
&amp;令~i~为常数，f(j)~为凸函数，即~f(j)-f(j-1)\le
f(j+1)-f(j)~或~f(j)-f(j-1)\ge f(j+1)-f(j)~\\\\
&amp;令~j \to +\infty，f(i)=\min/\max\{g(i)+w(i,j)\}
~能在~O(n)~时间内计算。
\end{align}
\]</span></p>
<h3 id="题目类型">题目类型</h3>
<p>给定 <span class="math inline">\(N\)</span> 个物品，每个物品有其价值
<span class="math inline">\(w\)</span>（<span class="math inline">\(w\)</span> 可以为负数）
，<strong>限制</strong>从其中选取 <span class="math inline">\(M\)</span>
（<span class="math inline">\(m \le
n\)</span>）个物品，求最大选取总价值。</p>
<h3 id="朴素dp思路">朴素DP思路</h3>
<p>（这里看似可以直接排序 <span class="math inline">\(O(n\log
n)\)</span> ，但是题目中价值 <span class="math inline">\(w\)</span>
往往较复杂，不能简单的排序后贪心）</p>
<p>设 <span class="math inline">\(f(i,j)\)</span> 为前 <span class="math inline">\(i\)</span> 个物品中，选取 <span class="math inline">\(j\)</span>
个物品的最大价值。则状态转移方程为：</p>
<p><span class="math display">\[
f(i,j)=\max\{f(i-1,j),f(i,j-1)+w(i)\},\quad j \in [1,i]
\]</span></p>
<p>这个朴素版本的做法的时间复杂度是 <span class="math inline">\(O(n^2)\)</span> 。而WQS二分能优化至 <span class="math inline">\(O(n\log n)\)</span> 。</p>
<h3 id="wqs二分解题思路">WQS二分解题思路</h3>
<h4 id="检查-ficj-关于-j-的凸性">1. 检查 <span class="math inline">\(f(i=C,j)\)</span> 关于 <span class="math inline">\(j\)</span> 的凸性</h4>
<p>既然要优化，那么一定是利用了函数的某种性质，这里也是利用的<strong>凹凸性</strong>。</p>
<p>将 <span class="math inline">\(f(i,j)\)</span> 看作以选取物品 <span class="math inline">\(j\)</span> 为自变量的函数，<span class="math inline">\(i\)</span> 为其中的常数，把 <span class="math inline">\(j\)</span> 改写为 <span class="math inline">\(x\)</span> ，则有函数 <span class="math inline">\(f(i=C,x)\)</span> 。</p>
<p>注意到 <span class="math inline">\(f(i=C,x)\)</span>
为<strong>上凸函数</strong>，即满足：</p>
<p><span class="math display">\[
f(x-1)-f(x) \ge f(x) - f(x+1)
\]</span></p>
<p>这个很容易想到，我们每次选取物品，必然选最好的，下一轮选择肯定只能选到没那么好的或同样好的。这增长率不就单调不减了嘛。</p>
<h4 id="简化问题不限制-j-时的-fij不限制-很好算">2. 简化问题：不限制
<span class="math inline">\(j\)</span> 时的 <span class="math inline">\(f(i,j=不限制)\)</span> 很好算</h4>
<p><strong>假设不限制选取物品个数</strong>，求最大选取总价值。当然全都选就是
<span class="math inline">\(N\)</span> 个。则：</p>
<p><span class="math display">\[
f(i,x=不限制)=\max\{f(i-1),f(i-1)+w(i)\}, \quad i \in [1,N]
\]</span></p>
<p>这个是一个 <span class="math inline">\(O(n)\)</span>
的过程。最终答案为 <span class="math inline">\(f(i=N)\)</span> 。</p>
<p>此时选取了 <span class="math inline">\(0\le t \le N\)</span>
个物品。虽然没有指定一定要选几个，但只选 <span class="math inline">\(t\)</span>
个是最优的，剩下的物品是负数，不选。所以 <span class="math inline">\(f(i=N,x=t)=f(i=N)\)</span> 。这样就以 <span class="math inline">\(O(n)\)</span> 时间就算出了 <span class="math inline">\(f(N,t)\)</span> 。</p>
<p>要是 <span class="math inline">\(t=M\)</span> 的话，岂不是直接算出了
<span class="math inline">\(f(N,M)\)</span> ！？确实如此，但可惜 <span class="math inline">\(f(i=C,x)\)</span> 的最大值点不一定是 <span class="math inline">\(M\)</span> 。</p>
<h4 id="凸函数加减-kx-凸性不变最值点单调移动">3. 凸函数：加减 <span class="math inline">\(kx\)</span> 凸性不变，最值点单调移动</h4>
<p>现在我们来观察<strong>凸函数</strong>的性质：（以二次函数为例）</p>
<p><strong>“用原凸函数构造新凸函数，用新凸函数的最值点，可以反求原凸函数上横坐标相同的点。”</strong></p>
<p><strong>“而凸函数的最值点很好计算，进而加速了原凸函数上任意一点的计算。”</strong></p>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/WQS%E4%BA%8C%E5%88%86-%E4%BB%A5%E4%BA%8C%E6%AC%A1%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BE%8B-17071412833312-1712573757010-13.gif" srcset="/img/loading.gif" lazyload alt="WQS二分-以二次函数为例">
<figcaption aria-hidden="true">WQS二分-以二次函数为例</figcaption>
</figure>
<p>在二次函数 <span class="math inline">\(y=ax^2+bx+c\)</span>
中，最值点的横坐标为 <span class="math inline">\(t=-\frac{b}{2a}\)</span> 。给函数减去 <span class="math inline">\(kx\)</span> 相当于减小 <span class="math inline">\(b\)</span> 的值，此时最值点的横坐标增大。所以
<span class="math inline">\(F(x)=f(x)-kx\)</span> 的最值点横坐标 <span class="math inline">\(t&#39;\)</span> 关于 <span class="math inline">\(k\)</span> 是单调的。</p>
<p>当我们遍历所有的 <span class="math inline">\(k\)</span>
值，就可通过不同的 <span class="math inline">\(F_{max}(x)=F(t)\)</span>
计算出 <span class="math inline">\(f(x)\)</span>
上的所有点。我们通过二分搜索来查找 <span class="math inline">\(F_{max}(x)=F(t=M)\)</span> 对应的 <span class="math inline">\(k\)</span> 值，即可得到 <span class="math inline">\(f(x=M)\)</span> 。如果这里常量 <span class="math inline">\(i=N\)</span> ，则得到了 <span class="math inline">\(f(N,M)\)</span> 。</p>
<blockquote>
<p>实际上，所有与 <span class="math inline">\(f(x)\)</span> 相交的直线
<span class="math inline">\(y=kx+F(x)\)</span> 构成了 <span class="math inline">\(F(x)\)</span> 的图像。所以当 <span class="math inline">\(y=kx+F(x)\)</span> 是 <span class="math inline">\(f(x)\)</span> 的切线时，取得 <span class="math inline">\(F(x)\)</span> 的最值点。</p>
</blockquote>
<h4 id="加减-kx-构造新凸函数用其最值点求-fij">4. 加减 <span class="math inline">\(kx\)</span> 构造新凸函数，用其最值点求 <span class="math inline">\(f(i,j)\)</span></h4>
<p>前面是连续函数，下面我们来看<strong>离散型</strong>的函数是否也是这样。</p>
<p>我们利用其<strong>凸性</strong>，用一条直线对其相切：</p>
<p><span class="math display">\[
f(j) = kj + b
\]</span></p>
<p>为了更加直观，写为 <span class="math inline">\(f(x)=kx+b\)</span>
。我们设 <span class="math inline">\(F(x)=b=f(x)-kx\)</span>
。这里设常数 <span class="math inline">\(i=N\)</span>。</p>
<p>图中 <span class="math inline">\(f(N,x)\)</span> 上的每个点都需要
<span class="math inline">\(O(n^2)\)</span> 的时间计算得出。如果我们计算
<span class="math inline">\(f(N,x=不限制)\)</span> ，就是 <span class="math inline">\(O(n)\)</span> 。</p>
<p>是否有办法让 <span class="math inline">\(f(N,x)\)</span>
上任意一点的计算速度和 <span class="math inline">\(f(N,x=不限制)\)</span> 一样快？</p>
<p>我们发现可以利用<strong>切点</strong>来计算 <span class="math inline">\(f(N,x)\)</span> 。令 <span class="math inline">\(f(N,x)=kx+b\)</span> ，截距 <span class="math inline">\(b=f(N,x)-kx=F(N,x)\)</span> 。</p>
<p>假设 <span class="math inline">\(x=t\)</span> 时取得 <span class="math inline">\(F(N,x)\)</span> 的最大值，此时 <span class="math inline">\(b_{max}=F_{max}(N,x)=F(N,t)\)</span> 就是 <span class="math inline">\(f(N,x)\)</span> 的切线的截距。根据计算得出的切线
<span class="math inline">\(y=kx+b_{max}\)</span> ，我们就可以计算得到
<span class="math inline">\(f(t)=kt+b_{max}\)</span> 。</p>
<p><img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/WQS_%E4%BF%AE%E6%AD%A3_%E7%9B%B4%E7%BA%BF%E4%B8%8E%E5%87%B8%E5%87%BD%E6%95%B0-1712573757010-14.svg" srcset="/img/loading.gif" lazyload></p>
<p>现在我们思考 <span class="math inline">\(F(N,x=不限制)\)</span>
的情况：</p>
<p>我们计算 <span class="math inline">\(F(N,x=不限制)\)</span>
的最优值，那么它自然一定是 <span class="math inline">\(F(N,x)\)</span>
的最大值。并且通过证明可知 <span class="math inline">\(t \in
[1,N]\)</span> 。简单的高中方法证明如下：</p>
<p><span class="math display">\[
\begin{align}
设&amp;~f(x)~为前~N~个物品中取~x~个物品时的最大总价值。这里不再把~N~写在函数参数括号中。\\
\because&amp;~~~f(x)-f(x-1)\ge f(x+1)-f(x)。\\
\therefore&amp;~~f(x)~为上凸函数，f&#39;&#39;(x)\le 0。\\
设&amp;~F(x)=f(x)-kx,~~F_{max}(x)=F(t)。
\\则&amp;~F&#39;(x)=f&#39;(x)-k，F&#39;&#39;(x)=f&#39;&#39;(x)\le
0，F(x)~也为上凸函数。\\
\\
对&amp;~f&#39;(x)~进行分类讨论:\\
①&amp;~~f&#39;(1)\lt k,~~f&#39;(N)\gt k \\
&amp;~~由于~f&#39;(x)~单调不增，不成立，舍去。\\
\\
②&amp;~~f&#39;(1)\lt k,~~f&#39;(N)\le k \\
&amp;~~由于~f&#39;(x)~单调不增，故~f&#39;(x)&lt;k。\\
\therefore&amp;~~~F&#39;(x)&lt; 0,~F(x)~单调递减。\\
\therefore&amp;~~~F(t)=F_{max}(x)=F(1)\\
\\
③&amp;~~f&#39;(1)\ge k,~~f&#39;(N)\gt k \\
&amp;~~~由于~f&#39;(x)~单调不增，故~f&#39;(x)&gt;k\\
\therefore&amp;~~~F&#39;(x)&gt;0,~F(x)~单调递增。\\
\therefore&amp;~~~F(t)=F_{max}(x)=F(N)\\
\\
④&amp;~~f&#39;(1)\ge k,~~f&#39;(N)\le k \\
\therefore&amp;~~~F&#39;(1)=f&#39;(1)-k \ge 0,~~F&#39;(N)=f&#39;(N)-k
\le 0\\
\therefore&amp;~~~ 由零点定理可得~F(x)~极大值点~t \in[1,N]。\\
\\
综&amp;上所述，F(x)的极大值点~t \in[1,N]。
\end{align}
\]</span></p>
<p>所以：</p>
<p><span class="math display">\[
\begin{align}
F_{max}(N,x)&amp;=F(N,t)=F(N,x=不限制),\quad t \in [1,N]
\end{align}
\]</span></p>
<p>我们算出了该 <span class="math inline">\(k\)</span> 值下的 <span class="math inline">\(F_{max}(N,x)\)</span> 之后，此时 <span class="math inline">\(b_{max}=F_{max}(N,x)\)</span> 就是 <span class="math inline">\(f(N,x)\)</span> 的切线的截距。根据切线 <span class="math inline">\(y=kx+b_{max}\)</span> ，就可以得到 <span class="math inline">\(f(N,t)\)</span> 上的切点 <span class="math inline">\((t,kt+b_{max})\)</span> ，也就计算出了 <span class="math inline">\(f(N,t)\)</span> ：</p>
<p><span class="math display">\[
f(N,t)=kt+b_{max}=kt+F(N,t)=kt+F(N,x=不限制)
\]</span></p>
<p>其中 <span class="math inline">\(F(N,x=不限制)\)</span> 的计算是
<span class="math inline">\(O(n)\)</span> 的：（下面 <span class="math inline">\(i\)</span> 意思是前 <span class="math inline">\(i\)</span> 个物品中取不限制个物品）</p>
<p><span class="math display">\[
F(i)=max\{F(i-1),F(i-1)+w(i)-k\},\quad i \in [1,N]
\]</span></p>
<h4 id="二分搜索合适的-k-值得到-fnm">5. 二分搜索合适的 <span class="math inline">\(k\)</span> 值，得到 <span class="math inline">\(f(N,M)\)</span></h4>
<p>这是不是意味着计算 <span class="math inline">\(f(N,x)\)</span>
的速度变成了 <span class="math inline">\(O(n)\)</span>
呢？还不是。因为我们并不能控制 <span class="math inline">\(t=M\)</span>
，所以我们该如何得到想要的 <span class="math inline">\(f(N,M)\)</span>
呢？难道碰运气？</p>
<p>观察 <span class="math inline">\(k\)</span> 取不同值时的 <span class="math inline">\(F(N,x)\)</span> 图像，容易发现<strong>它的极值点
<span class="math inline">\(x=t\)</span> 随 <span class="math inline">\(k\)</span> 的增大而减小</strong>，这是由于 <span class="math inline">\(f(N,x)\)</span>
的凸性导致的。这个也很好证明，但是懒得写了。ψ(｀∇´)ψ</p>
<p>因此，我们可以考虑在一定范围内对 <span class="math inline">\(k\)</span> 进行二分搜索，直到找到某个 <span class="math inline">\(F_k(N,x)\)</span> 的极大值点 <span class="math inline">\(x=t=M\)</span> ，这样我们就获得了 <span class="math inline">\(f(N,M)\)</span> 的值。二分搜索的时间复杂度为 <span class="math inline">\(O(\log n)\)</span> ，每次计算 <span class="math inline">\(F_k(N,x=不限制)\)</span> 的时间复杂度为 <span class="math inline">\(O(n)\)</span> ，总时间复杂度为 <span class="math inline">\(O(n\log n)\)</span> 。</p>
<blockquote>
<p>还可以对WQS二分这样简单理解：每选取一个物品，额外减少 k
的价值，从而间接限制DP对物品的选择数量。</p>
</blockquote>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/WQS_%E4%BF%AE%E6%AD%A3-17067678589501-1712573757010-15.svg" srcset="/img/loading.gif" lazyload alt="WQS二分中不同的k值所对应的F极值点">
<figcaption aria-hidden="true">WQS二分中不同的k值所对应的F极值点</figcaption>
</figure>
<blockquote>
<p>对 <span class="math inline">\(k\)</span> 进行二分搜索的范围，最大为
<span class="math inline">\([0,\max\{w(i)\}]\)</span> 。</p>
<p>由于本题 <span class="math inline">\(f(x)\)</span> 的斜率 <span class="math inline">\(f&#39;(N,x)=f(N,x)-f(N,x-1)\)</span>
始终为整数，所以切点 <span class="math inline">\((t,kt+b_{max})\in
f(N,x)\)</span> 的 <span class="math inline">\(k\)</span>
也为整数，因此只需要<strong>整数二分</strong>。如果斜率存在小数，则需要<strong>实数二分</strong>，涉及到浮点数中的精度处理。可以固定实数二分的查找次数，以决定
<span class="math inline">\(k\)</span> 的精度。</p>
</blockquote>
<h4 id="特别注意事项">6. 特别注意事项</h4>
<h5 id="注意多点共线">(1) 注意多点共线</h5>
<p>需要特别特别注意的是你的 <strong>整数二分 和 <span class="math inline">\(F_k(N,x=不限制)\)</span>
的计算要匹配！！！</strong></p>
<p>如果 <strong>F
的最值是多点共线</strong>，我们将不能简单地通过整数二分搜索直接获得<strong>中间</strong>的点，<strong>只能获得端点</strong>。搜索出的
<span class="math inline">\(x=t\)</span> 并不一定等于 <span class="math inline">\(M\)</span>
！！！但是可以由端点计算中间的点，因为它们的 <span class="math inline">\(F\)</span> 的值都是一样的，只是 <span class="math inline">\(f\)</span> 需要加上的 <span class="math inline">\(kx\)</span> 不同。</p>
<p>当我们计算出共线的某一个端点的 <span class="math inline">\(F_{max}(N,x)\)</span>
时，则可以计算出这条线段上的所有 <span class="math inline">\(f(N,x)\)</span> 的值，具体见模板题。</p>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/WQS_%E5%85%B1%E7%BA%BF-1712573757010-16.svg" srcset="/img/loading.gif" lazyload alt="WQS_共线">
<figcaption aria-hidden="true">WQS_共线</figcaption>
</figure>
<p><strong>如果一不注意就会 WA ！！！！！！！！！！！！QwQ</strong></p>
<p>当然实数二分就基本上没有这个烦恼，但是要注意处理好 eps 。</p>
<p>例题：WQS二分模板题第1题：邮局；WQS二分练习题：aliens</p>
<h5 id="注意-m-是否永远无法通过二分取到">(2) 注意 M
是否永远无法通过二分取到</h5>
<p>如果 $t &lt; M <sub>or</sub>M&lt;t $ 成立，则 <span class="math inline">\(M\)</span> 对应的 <span class="math inline">\(F(N,M)\)</span> 100%和二分边界的 <span class="math inline">\(F(N,t)\)</span> 共线，如果你的 <span class="math inline">\(f(N,M)\)</span>
计算放在二分循环内，将要特别考虑此种情况。</p>
<p>具体见练习题：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1484">P1484
种树</a>
的这行代码：<code>if (ans == -1) ans = val + k * mid;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ll l = <span class="hljs-number">0</span>, r = *<span class="hljs-built_in">max_element</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>), mid, val, cnt, ans = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>    mid = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">tie</span>(val, cnt) = <span class="hljs-built_in">check</span>(mid, ans);<br>    <span class="hljs-keyword">if</span> (cnt &gt;= k) l = mid + <span class="hljs-number">1</span>, ans = val + k * mid;<br>    <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 因为 cnt 最大为树坑为非负数的个数，所以 cnt 可能恒小于 k</span><br><span class="hljs-keyword">if</span> (ans == <span class="hljs-number">-1</span>) ans = val + k * mid;<br></code></pre></td></tr></table></figure>
<h4 id="wqs二分的拓展">WQS二分的拓展</h4>
<h5 id="a.-多重wqs二分">A. 多重WQS二分</h5>
<p>如果同时对两个受限制的变量进行二分，则相当于在凸曲面上寻找最值，利用的是曲面的凸性。</p>
<p>可以拓展至对任意多个受限制的变量进行二分，只要你能证明关于每个变量的
<span class="math inline">\(f\)</span> 都有凸性。</p>
<p>我们首先将问题简化为每一个变量都不受限制的情况，得到此时的 <span class="math inline">\(f(i)\)</span> ，然后设计 <span class="math inline">\(F(x)\)</span>
。通过多层嵌套的二分搜索（每一层搜索一个变量的 <span class="math inline">\(k\)</span> 值）搜索结果。</p>
<p>例题：WQS二分模板题第2题：CF739E Gosha is hunting</p>
<h5 id="b.-对任意凸函数中受限制变量进行二分">B.
对任意凸函数中受限制变量进行二分</h5>
<p>是的，WQS二分不仅仅可用于一般的DP最优化问题。只要你的问题是最优化问题，含有受限制参数，函数关于受限制变量是凸函数，就可以二分这个额外权重
<span class="math inline">\(k\)</span>
来搜索答案。（和树、图等等结合）</p>
<p>例题：WQS二分模板题第3题：P2619 [国家集训队] Tree I</p>
<h5 id="c.-对非凸函数进行wqs二分">C. 对非凸函数进行WQS二分</h5>
<p>以下内容仅仅为个人猜想，正确性未经过证明。</p>
<mydetails>
<summary>
<summary-title>Conjecture</summary-title><summary-subtitle>对非凸函数使用WQS二分的猜想</summary-subtitle>
</summary>
<p>设状态转移方程为： <span class="math inline">\(f(i,j)=optim\{g(i,j)+w(i)\}=optim\{G(i,j)\}\)</span>
。</p>
<p>则我们观察函数性质的域为： <span class="math inline">\(\begin{align}f(N,j)&amp;=optim\{g(N,j)+w(N)\}=optim\{G(N,j)\}\\
\Rightarrow f(x)&amp;=optim\{G(x)\}\end{align}\)</span> 。</p>
<p>如果当 <span class="math inline">\(f(i,j)\)</span> 关于 <span class="math inline">\(j\)</span>
不是凸函数，但<strong>定义域内只有一个极值点</strong>，即 <span class="math inline">\(f&#39;=0\)</span>
在定义域内有且仅有一个解，此时也是可以通过某种手段构造出极值点偏移的新函数的。但是就不是
<span class="math inline">\(kx\)</span> 了，可能是 <span class="math inline">\(k\ln x\)</span> 、<span class="math inline">\(k\sqrt{x}\)</span> 、<span class="math inline">\(\frac{k}{x}\)</span>
等等。具体如何选择合适的偏移项来构造，需要具体观察。</p>
<p><strong>例一</strong></p>
<p>下式中 <span class="math inline">\(f\)</span> 并不是凸函数，因为
<span class="math inline">\(f&#39;&#39;=\frac{2\ln x-3}{x^3}\)</span>
有一个零点。我们参考 <span class="math inline">\(f\)</span> 构造新的函数
<span class="math inline">\(F\)</span> ，并且使得 <span class="math inline">\(F&#39;=0\)</span>
在定义域内同样有且仅有一个解。</p>
<p><span class="math display">\[
\begin{align}
f(N,x)&amp;=f(x)=\frac{\ln(x)}{x},~f&#39;(x)=\frac{1-\ln x}{x^2}
\\F(N,x)&amp;=f(N,x)+\frac{k}{x}, ~~F&#39;(x)=\frac{1-\ln x-k}{x^2}
\end{align}
\]</span></p>
<p>易知 <span class="math inline">\(f\)</span> 有且仅有一个极值点，即
<span class="math inline">\(\ln x =1\)</span> 的时候。同时可知 <span class="math inline">\(F\)</span> 也是有且仅有一个极值点，即 <span class="math inline">\(\ln x =1-k\)</span>
的时候。因此可以使用WQS二分</p>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/WQS%20%E9%9D%9E%E5%87%B8%E5%87%BD%E6%95%B0-1712573757010-17.gif" srcset="/img/loading.gif" lazyload alt="WQS 非凸函数">
<figcaption aria-hidden="true">WQS 非凸函数</figcaption>
</figure>
<p>可见此方法可能在特定情境下有作用。</p>
<p><strong>例二</strong></p>
<p>下面 <span class="math inline">\(f(x)\)</span>
不是凸函数，考虑将其取倒数，则转变为二次函数。以此构造 <span class="math inline">\(F(x)\)</span> 。</p>
<p><span class="math display">\[
f(N,x)=f(x)=\frac{1}{x^2+1}\\
F(N,x)=F(x)=-\frac{1}{f(x)}+kx=x^2+kx+1
\]</span></p>
<p>则此时 <span class="math inline">\(f(x)=\frac{1}{kx-F(x)}\)</span>
。由 <span class="math inline">\(F(N, x=不限制)\)</span> 获得 <span class="math inline">\(f(N,x)\)</span> 的过程如下图所示：</p>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/WQS%E4%BA%8C%E5%88%86%E9%9D%9E%E5%87%B8%E5%87%BD%E6%95%B0%E7%8C%9C%E6%83%B3%20%E4%BE%8B2-1712573757010-18.gif" srcset="/img/loading.gif" lazyload alt="WQS二分非凸函数猜想 例2">
<figcaption aria-hidden="true">WQS二分非凸函数猜想 例2</figcaption>
</figure>
<p><strong>后记</strong></p>
<p>以上均为连续函数，对于离散函数，比较难判断它的性质，所以感觉这个方法也没什么用。仅仅作为WQS的深入思考。也许最优化理论里面有这些研究吧。等以后学了最优化回来看看。ψ(｀∇´)ψ</p>
<blockquote>
<p>要是我出WQS的题，就拿这个性质搞搞，嘻嘻~</p>
</blockquote>
<p></p></mydetails><p></p>
<hr>
<p>以上就是<strong>WQS二分</strong>的详细过程与证明。</p>
<p>国内一般认为该算法最早由王钦石在2012年的国家集训队论文提及，故称为WQS二分。国外称为
Aliens' Trick ，源自2016年 IOI 赛题 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5896">aliens</a>
的WQS二分解法。</p>
<h3 id="wqs二分模板题">WQS二分模板题</h3>
<h4 id="p4767-ioi2000-邮局">1. <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4767">P4767 IOI2000
邮局</a></h4>
<p><strong>题目描述</strong></p>
<p>高速公路旁边有一些村庄。高速公路表示为整数轴，每个村庄的位置用单个整数坐标标识。没有两个在同样地方的村庄。两个位置之间的距离是其整数坐标差的绝对值。</p>
<p>邮局将建在一些，但不一定是所有的村庄中。为了建立邮局，应选择他们建造的位置，使每个村庄与其最近的邮局之间的距离总和最小。</p>
<p>你要编写一个程序，已知村庄的位置和邮局的数量，计算每个村庄和最近的邮局之间所有距离的最小可能的总和。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含两个整数：第一个是村庄 <span class="math inline">\(V\)</span> 的数量，第二个是邮局的数量 <span class="math inline">\(P\)</span>。</p>
<p>第二行包含 <span class="math inline">\(V\)</span>
个整数。这些整数是村庄的位置。</p>
<p><strong>输出格式</strong></p>
<p>第一行包含一个整数<span class="math inline">\(S\)</span>，它是每个村庄与其最近的邮局之间的所有距离的总和。</p>
<p><strong>提示</strong></p>
<p>对于 <span class="math inline">\(40\%\)</span> 的数据，<span class="math inline">\(V \leq 300\)</span>。</p>
<p>对于 <span class="math inline">\(100\%\)</span> 的数据，<span class="math inline">\(1 \leq P \leq 300\)</span>，<span class="math inline">\(P \leq V \leq 3000\)</span>，$1 $ 村庄位置 <span class="math inline">\(\leq 10000\)</span>。</p>
<p><strong>WQS解题思路</strong></p>
<p>参考博客：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ydtz/p/16536706.html">【ydtz】奇淫技巧——wqs二分</a></p>
<blockquote>
<p>在分布在一条直线上的 <span class="math inline">\(n\)</span>
个村庄中选 <span class="math inline">\(k\)</span>
个建立邮局，求所有村庄到达其最近邮局的最小距离之和。<span class="math inline">\(n\le 3000,k\le 300\)</span>.</p>
</blockquote>
<p>这是一道四边形不等式优化 dp
的题目，但是四边形不等式好麻烦，我们不想用它 &gt;_&lt;</p>
<p>暴力的 dp 会怎么做它呢？我们通常会设 <span class="math inline">\(dp_{i,j}\)</span> 表示前 i 个村庄放 j
个邮局时的最小距离距离之和，于是有</p>
<p><span class="math display">\[
dp_{i,j}=\min(dp_{p,j-1}+w(p+1,i))\ ,\ (0\le p &lt;i)
\]</span></p>
<p>其中 <span class="math inline">\(w(i,j)\)</span> 表示的是在区间 <span class="math inline">\([i,j]\)</span>
中建立邮局，且该区间内的村庄与该邮局的距离之和。运用一些中位数的知识，显然邮局应该建立在该区间最中间的村庄内。</p>
<p>这样看来 dp 转移是 <span class="math inline">\(O(n^2k)\)</span>
的，计算 <span class="math inline">\(w(i,j)\)</span> 是 <span class="math inline">\(O(n)\)</span> 的，总复杂度到达了恐怖的 <span class="math inline">\(O(n^3k)\)</span>。</p>
<p>考虑继续优化，我们发现 <span class="math inline">\(w(i,j)\)</span>
是可以通过预处理提前求出的，由于一个区间向左右同时扩展一格时中位数不变，所以有递推式：</p>
<p><span class="math display">\[
w(i,i)=w(i+1,i)=0\\
w(i,j)=w(i+1,j-1)+a_j-a_i\ ,\ i\le j-1
\]</span></p>
<p>所以我们可以在 <span class="math inline">\(O(n^2)\)</span>
的复杂度内将 <span class="math inline">\(w(i,j)\)</span> 预处理出来，dp
的时间复杂度就优化到了 <span class="math inline">\(O(n^2k)\)</span>
。</p>
<p>但是仍然过不去。<del>考虑继续用四边形不等式优化</del>
拒绝四边形不等式！</p>
<p>我们发现其实 <span class="math inline">\(n^2\)</span>
完全是能过的，只要我们能将 <span class="math inline">\(k\)</span> 优化到
<span class="math inline">\(\log n\)</span>，他也是能过的。</p>
<p>但是单纯的 dp 显然无法做到，因为选择 <span class="math inline">\(k\)</span>
个物品这个条件所增加的状态数就足以支撑起 <span class="math inline">\(O(k)\)</span> 的时间复杂度。</p>
<p>这时就需要用我们的奇淫技巧——<strong>wqs 二分</strong>。</p>
<p>依旧设 <span class="math inline">\(f(i)\)</span> 为设立 <span class="math inline">\(i\)</span>
个邮局时的最小距离之和，则有两个性质：</p>
<ol type="1">
<li><p><span class="math inline">\(f(i)&lt;f(i−1)\)</span></p></li>
<li><p><span class="math inline">\(f(i)−f(i−1)≤f(i+1)−f(i)\)</span></p></li>
</ol>
<p>第一条十分显然，每增加一个邮局后的答案显然是不劣，主要看第二条。</p>
<p>第二条其实也很容易想到——每一个邮局造成影响的村庄都一定是一段区间，若后一个邮局的贡献会比前一个优，则前面显然可以先选择后一个邮局的位置建立邮局而非前一个邮局的位置，故贪心的讲，越靠前设立的邮局贡献一定越大。</p>
<p>通过这两条性质，我们可以很容易地推断出 <span class="math inline">\(f(i)\)</span>
的函数图像是一个下凸壳，于是就可以通过 wqs
二分将邮局个数的限制去掉，再跑 <span class="math inline">\(O(n^2)\)</span> dp 即可，时间复杂度 <span class="math inline">\(O(n^2 \log |V|)\)</span>，<span class="math inline">\(|V|\)</span> 是二分的值域。</p>
<p><strong>解题代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_V = <span class="hljs-number">3007</span>, MAX_P = <span class="hljs-number">307</span>;<br><span class="hljs-type">int</span> V, P;<br><span class="hljs-type">int</span> a[MAX_V], asum[MAX_V];  <span class="hljs-comment">// a[i] 表示村庄 i 的位置，asum[i] 表示前缀和（前 i 个村庄的位置和）</span><br><span class="hljs-comment">// 用前缀和 O(1) 计算 w(i,j)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">W</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>    <span class="hljs-type">int</span> mid = (i + j) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> (asum[j] - asum[mid]) - (asum[mid] - asum[i - <span class="hljs-number">1</span>] - a[mid] * ((i + j + <span class="hljs-number">1</span>) &amp; <span class="hljs-number">1</span>));<br>&#125;<br><span class="hljs-comment">// NOTE 这里可以用决策单调性二分队列优化为 O(nlogn)</span><br><span class="hljs-comment">// F(i) = min(F(j)+W(j+1,i)+k)</span><br><span class="hljs-comment">// 普通做法：check一次是O(n^2)，这里规定相同的消耗下，尽可能多建邮局</span><br><span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(F, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(F));<br>    F[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= V; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>, tmp; j &lt; i; j++) &#123;  <span class="hljs-comment">// 注意j可以也必须从0开始</span><br>            tmp = F[j] + <span class="hljs-built_in">W</span>(j + <span class="hljs-number">1</span>, i) + k;<br>            <span class="hljs-keyword">if</span> (tmp &lt;= F[i]) &#123;<br>                <span class="hljs-comment">// 尽可能少建邮局</span><br>                <span class="hljs-keyword">if</span> (tmp == F[i]) cnt[i] = <span class="hljs-built_in">min</span>(cnt[i], cnt[j] + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">else</span> cnt[i] = cnt[j] + <span class="hljs-number">1</span>;<br>                F[i] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;F[V], cnt[V]&#125;;<br>&#125;<br><span class="hljs-comment">// WQS二分查找：共查找 log2(n)=log2(3e7)=25 次</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">3000</span> * <span class="hljs-number">10000</span>, mid, ans;<br>    <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>        mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">auto</span> [Fx, cnt] = <span class="hljs-built_in">check</span>(mid);<br>        <span class="hljs-keyword">if</span> (cnt &gt; P) &#123;<br>            l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// [Fx, cnt] 是第一个 &gt;= P 的位置</span><br>            ans = F[V] - mid * P;   <span class="hljs-comment">// ans 和它共线</span><br>            r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; V &gt;&gt; P;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= V; i++) cin &gt;&gt; a[i];<br>    <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + V + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= V; i++) asum[i] = asum[i - <span class="hljs-number">1</span>] + a[i];<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>左边是尽可能少建邮局，右边是尽可能多建邮局，它们的二分搜索和 <span class="math inline">\(F\)</span> 计算是不同的！</p>
<p>注意整数二分的时候，答案的计算一定是在二分循环里面的，因为考虑到共线的情况，如果要算的点在共线的线段中间，我们整数二分搜索是肯定搜不到的，必须通过端点来计算！（端点选哪一个根据你
<span class="math inline">\(F\)</span> 选择的贪心策略）</p>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-02-01%20015608%20-%20%E5%89%AF%E6%9C%AC-1712573757010-19.png" srcset="/img/loading.gif" lazyload alt="代码差异">
<figcaption aria-hidden="true">代码差异</figcaption>
</figure>
<p>两种都能成功AC。但你要是搞错了一步就是一片的WA了！！！！虽然有的时候也能因为共线而AC。(～￣▽￣)～</p>
<figure>
<img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/image-20240201020150336-1712573757010-20.png" srcset="/img/loading.gif" lazyload alt="两种方式都可AC">
<figcaption aria-hidden="true">两种方式都可AC</figcaption>
</figure>
<h4 id="cf739e-gosha-is-hunting">2. <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF739E">CF739E Gosha is
hunting</a></h4>
<p><strong>题目描述</strong></p>
<p>你要抓神奇宝贝！ 现在一共有 <span class="math inline">\(n\)</span>
只神奇宝贝（ <span class="math inline">\(n \le 10^5\)</span> ）。你有
<span class="math inline">\(a\)</span> 个『宝贝球』和 <span class="math inline">\(b\)</span> 个『超级球』，其抓到第 <span class="math inline">\(i\)</span> 只神奇宝贝的概率分别是 <span class="math inline">\(p_i\)</span> 和 <span class="math inline">\(q_i\)</span>
，每种球不能在同一只神奇宝贝上使用多次。求最优策略下，抓到神奇宝贝的总个数期望最大值，保留五位小数。</p>
<p><strong>WQS解题思路</strong></p>
<p>这道题很好地指出了<strong>多重WQS二分</strong>是如何操作的。</p>
<p>设 <span class="math inline">\(f(i,j,k)\)</span> 为前 <span class="math inline">\(i\)</span> 个神奇宝贝中，用了 <span class="math inline">\(j\)</span> 个宝贝球和 <span class="math inline">\(k\)</span> 个超级球的最大期望值。</p>
<p><span class="math display">\[
\begin{align}
f(i,j,k)=max\{&amp;f(i-1,j,k),\\&amp;f(i-1,j-1,k)+p(i),\\&amp;f(i-1,j,k-1)+q(i),\\&amp;f(i-1,j-1,k-1)+1-(1-p(i))(1-q(i))\}
\end{align}
\]</span></p>
<p>去除限制，问题简化为：n
只神奇宝贝，<strong>任意使用宝贝球和超级球</strong></p>
<p>设 <span class="math inline">\(f(i)\)</span> 为前 <span class="math inline">\(i\)</span>
只神奇宝贝中，按照规则任意使用不限量宝贝球和超级球，抓到神奇宝贝的总个数期望最大值。</p>
<ol type="1">
<li>第 i 只不抓： <span class="math inline">\(f(i)=f(i-1)\)</span></li>
<li>第 i 只使用宝贝球： <span class="math inline">\(f(i)=f(i-1)+p(i)\)</span></li>
<li>第 i 只使用超级球： <span class="math inline">\(f(i)=f(i-1)+q(i)\)</span></li>
<li>第 i 只使用宝贝球和超级球： <span class="math inline">\(f(i)=f(i-1)+p(i)+q(i)-p(i)q(i)\)</span></li>
</ol>
<p><span class="math display">\[
\begin{align}
f(i)=\max\{
&amp;f(i-1),\\
&amp;f(i-1)+p(i),\\
&amp;f(i-1)+q(i),\\
&amp;f(i-1)+p(i)+q(i)-p(i)q(i)
\}
\end{align}
\]</span></p>
<p>设 <span class="math inline">\(F(i)=f(i)-c_aj-c_bk\)</span>
，则：</p>
<p><span class="math display">\[
\begin{align}
F(i)=\max\{
&amp;F(i-1),\\
&amp;F(i-1)+p(i)-c_a,\\
&amp;F(i-1)+q(i)-c_b,\\
&amp;F(i-1)+p(i)+q(i)-p(i)q(i)-c_a-c_b
\}
\end{align}
\]</span></p>
<p><span class="math inline">\(c_a\)</span> 和 <span class="math inline">\(c_b\)</span> 由两个二分搜索嵌套得到。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">2007</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-8</span>;<br><span class="hljs-type">int</span> n, a, b;<br><span class="hljs-type">double</span> p[MAXN], q[MAXN];<br><span class="hljs-type">double</span> F = -eps;<br><span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> ca, <span class="hljs-type">double</span> cb)</span> </span>&#123;<br>    <span class="hljs-type">double</span> prevF = <span class="hljs-number">0</span>, selnul, sela, selb, selab;<br>    <span class="hljs-type">int</span> prevCnta = <span class="hljs-number">0</span>, prevCntb = <span class="hljs-number">0</span>, cnta, cntb;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        sela   = prevF + p[i] - ca;<br>        selb   = prevF + q[i] - cb;<br>        selab  = prevF + p[i] + q[i] - p[i] * q[i] - ca - cb;<br>        F = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(prevF, sela), <span class="hljs-built_in">max</span>(selb, selab));<br>        <span class="hljs-keyword">if</span> (F - selab &lt; eps) cnta = prevCnta + <span class="hljs-number">1</span>, cntb = prevCntb + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (F - selb &lt; eps) cnta = prevCnta, cntb = prevCntb + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (F - sela &lt; eps) cnta = prevCnta + <span class="hljs-number">1</span>, cntb = prevCntb;<br>        <span class="hljs-keyword">else</span> cnta = prevCnta, cntb = prevCntb;<br>        prevF = F, prevCnta = cnta, prevCntb = cntb;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(cnta, cntb);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">double</span> la = <span class="hljs-number">0</span>, ra = <span class="hljs-number">1</span>, mida, lb, rb, midb;<br>    pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>    <span class="hljs-keyword">while</span> (la + eps &lt; ra) &#123;<br>        mida = (la + ra) / <span class="hljs-number">2</span>;<br>        lb = <span class="hljs-number">0</span>, rb = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (lb + eps &lt; rb) &#123;<br>            midb = (lb + rb) / <span class="hljs-number">2</span>;<br>            cnt = <span class="hljs-built_in">check</span>(mida, midb);<br>            <span class="hljs-keyword">if</span> (cnt.second &gt; b) lb = midb + eps;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt.second &lt; b) rb = midb;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cnt.first &gt; a) la = mida + eps;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt.first &lt; a) ra = mida;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 这里因为小数几乎不会共线，所以不考虑共线</span><br>    <span class="hljs-comment">// 如果是整数二分则万万不可草率地放在外面计算！！！</span><br>    cout &lt;&lt; F + mida * a + midb * b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; p[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; q[i];<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这道题很好地展示了多重WQS的代码，以及实数二分的WQS。思想和前一题邮局差不多。只要注意二分和F计算相匹配，可以轻松AC。</p>
<p>这里和上一题不同的是，答案的计算放在了二分循环外面，因为是实数二分，<strong>几乎不可能共线</strong>，所以最后二分出来的
<span class="math inline">\(k\)</span>
一定是等于限定值，可以直接使用。要注意二分出来的结果是哪个变量。</p>
<p>（WQS最容易出错的地方在于二分，因为二分本身写法多样，细节多，出错率高）</p>
<h4 id="p2619-国家集训队-tree-i">3. <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2619">P2619 国家集训队 Tree
I</a></h4>
<p><strong>题目描述</strong></p>
<p>给你一个无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有
need 条白色边的生成树。</p>
<p>题目保证有解。</p>
<p><strong>输入格式</strong></p>
<p>第一行 V,E,need 分别表示点数，边数和需要的白色边数。</p>
<p>接下来 E 行，每行 s,t,c,col 表示这边的端点（点从 0
开始标号），边权，颜色（0 白色 1 黑色）。</p>
<p><strong>输出格式</strong></p>
<p>一行，表示所求生成树的边权和。</p>
<p><strong>提示</strong></p>
<p>对于 5% 的数据，V≤10。 对于另 15% 的数据，V≤15。对于 100%
的数据，V≤5×10<sup>4,E≤10</sup>5。</p>
<p>所有数据边权为 [1,100] 中的正整数。</p>
<p><strong>WQS解题思路</strong></p>
<p><strong>WQS</strong></p>
<p>二分每次选择白色边的额外权重 k，然后求最小生成树的权重。</p>
<p><strong>Kruskal</strong></p>
<ol type="1">
<li>将所有边按权重从小到大排序</li>
<li>依次选择边，如果边的两个端点不在同一个集合中，则将这条边加入最小生成树中</li>
<li>直到最小生成树中有 V-1 条边</li>
<li>返回树中白色边的数量</li>
</ol>
<p><strong>WQS + Kruskal</strong></p>
<ol type="1">
<li>白边和黑边分别存储，然后按照权重排序</li>
<li>二分每次选择白色边的额外权重 k</li>
<li>为每条白色边的权重加上 k</li>
<li>重新排序所有边（归并排序白边和黑边）</li>
<li>用 Kruskal 求最小生成树</li>
<li>返回树中白色边的数量</li>
<li>如果白色边的数量大于等于 need，则说明 k 太大，否则 k 太小</li>
<li>二分直到找到最小的 k</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> V_MAX = <span class="hljs-number">5e4</span> + <span class="hljs-number">10</span>, E_MAX = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123; <span class="hljs-type">int</span> s, t, c, col; &#125;;<br><span class="hljs-type">int</span> wcnt, bcnt;<br>edge W[E_MAX], B[E_MAX], G[E_MAX];<br><span class="hljs-type">int</span> V, E, need;<br><span class="hljs-type">int</span> par[V_MAX];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> par[x] == x ? x : par[x] = <span class="hljs-built_in">find</span>(par[x]); &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> wp = <span class="hljs-number">0</span>, bp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; E; i++) &#123;<br>        <span class="hljs-keyword">if</span> (wp &lt; wcnt &amp;&amp; bp &lt; bcnt) &#123;<br>            <span class="hljs-keyword">if</span> (W[wp].c + k &lt;= B[bp].c) G[i] = W[wp++], G[i].c += k;<br>            <span class="hljs-keyword">else</span> G[i] = B[bp++];<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wp &lt; wcnt) G[i] = W[wp++], G[i].c += k;<br>        <span class="hljs-keyword">else</span> G[i] = B[bp++];<br>    &#125;<br>&#125;<br><span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">kruskal</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> val = <span class="hljs-number">0</span>, selwcnt = <span class="hljs-number">0</span>, selcnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++) par[i] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; E; i++) &#123;<br>        <span class="hljs-keyword">if</span> (selcnt == V - <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-type">int</span> par_s = <span class="hljs-built_in">find</span>(G[i].s), <span class="hljs-type">par_t</span> = <span class="hljs-built_in">find</span>(G[i].t);<br>        <span class="hljs-keyword">if</span> (par_s == <span class="hljs-type">par_t</span>) <span class="hljs-keyword">continue</span>;<br>        par[par_s] = <span class="hljs-type">par_t</span>;<br>        val += G[i].c;<br>        selwcnt += (G[i].col == <span class="hljs-number">0</span>);<br>        selcnt++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;val, selwcnt&#125;;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">-100</span>, r = <span class="hljs-number">100</span>, mid, val, cnt, ans;<br>    <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>        mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">mergeSort</span>(mid);<br>        <span class="hljs-built_in">tie</span>(val, cnt) = <span class="hljs-built_in">kruskal</span>();<br>        <span class="hljs-keyword">if</span> (cnt &gt;= need) l = mid + <span class="hljs-number">1</span>, ans = val - mid * need;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>    cin &gt;&gt; V &gt;&gt; E &gt;&gt; need;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; E; i++) &#123;<br>        <span class="hljs-type">int</span> s, t, c, col;<br>        cin &gt;&gt; s &gt;&gt; t &gt;&gt; c &gt;&gt; col;<br>        <span class="hljs-keyword">if</span> (col) B[bcnt++] = &#123;s, t, c, col&#125;;<br>        <span class="hljs-keyword">else</span> W[wcnt++] = &#123;s, t, c, col&#125;;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(W, W + wcnt, [](edge a, edge b) &#123; <span class="hljs-keyword">return</span> a.c &lt; b.c; &#125;);<br>    <span class="hljs-built_in">sort</span>(B, B + bcnt, [](edge a, edge b) &#123; <span class="hljs-keyword">return</span> a.c &lt; b.c; &#125;);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="wqs二分练习题">WQS二分练习题</h3>
<h4 id="p1484-种树"><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1484">P1484 种树</a></h4>
<p><strong>题意概述</strong></p>
<p>数轴上有 n 个点，每个点有一个价值
a（可以为负），两个点相邻则只能选其中一个。至多选 k
个点，计算最大价值。</p>
<p><strong>WQS解题思路</strong></p>
<p>很简单，直接WQS干就完了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">300007</span>;<br>ll n, k;<br><span class="hljs-type">int</span> a[MAXN];<br><span class="hljs-function">pair&lt;ll, ll&gt; <span class="hljs-title">check</span><span class="hljs-params">(ll C, ll&amp; ans)</span> </span>&#123;<br>    ll yes = a[<span class="hljs-number">1</span>] - C, no = <span class="hljs-number">0</span>, yesCnt = <span class="hljs-number">1</span>, noCnt = <span class="hljs-number">0</span>;<br>    ll prev_yes, prev_no, prev_yesCnt, prev_noCnt;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        prev_yes = yes, prev_no = no, prev_yesCnt = yesCnt, prev_noCnt = noCnt;<br>        yes = prev_no + a[i] - C;<br>        yesCnt = prev_noCnt + <span class="hljs-number">1</span>;<br>        no = <span class="hljs-built_in">max</span>(prev_yes, prev_no);<br>        <span class="hljs-comment">// 选择种树最多的方案</span><br>        <span class="hljs-keyword">if</span> (prev_yes == prev_no) noCnt = <span class="hljs-built_in">max</span>(prev_yesCnt, prev_noCnt);<br>        <span class="hljs-keyword">else</span> noCnt = (prev_yes &gt; prev_no) ? prev_yesCnt : prev_noCnt;<br>    &#125;<br>    ll val = <span class="hljs-built_in">max</span>(yes, no), cnt;<br>    <span class="hljs-keyword">if</span> (yes == no) cnt = <span class="hljs-built_in">max</span>(yesCnt, noCnt);<br>    <span class="hljs-keyword">else</span> cnt = (yes &gt; no) ? yesCnt : noCnt;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(val, cnt);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cin &gt;&gt; a[i];<br>    ll l = <span class="hljs-number">0</span>, r = *<span class="hljs-built_in">max_element</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>), mid, val, cnt, ans = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>        mid = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">tie</span>(val, cnt) = <span class="hljs-built_in">check</span>(mid, ans);<br>        <span class="hljs-keyword">if</span> (cnt &gt;= k) l = mid + <span class="hljs-number">1</span>, ans = val + k * mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 因为 cnt 最大为树坑为非负数的个数，所以 cnt 可能恒小于 k</span><br>    <span class="hljs-keyword">if</span> (ans == <span class="hljs-number">-1</span>) ans = val + k * mid;<br>    cout &lt;&lt; ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="p5896-ioi2016-aliens"><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5896">P5896 IOI2016
aliens</a></h4>
<p><strong>题意概述</strong></p>
<p>m x m 方格中填有非负整数，其和为 n
。规定左上到右下为对角线，选择的正方形区域的对角线必须和这条对角线重合。在对角线上选择正方形区域，使得正方形能够覆盖所有不为
0 的方格，并要求被覆盖的方格数最小。现在限制最多只能选择 k
个正方形，求最小的被覆盖的方格数。</p>
<p><strong>WQS解题思路</strong></p>
<ol type="1">
<li><p>凸性。那必然拍的越多，每次降低的费用就越少。</p></li>
<li><p>将方格左下三角形按照对角线对称到右上，不影响结果。</p></li>
<li><p>将每个点的坐标视为线段区间，这根线段则是在对角线上的。作正方形区域，相当于取对角线上的一个线段区间。</p></li>
<li><p>排序线段。对线段按照左端点从小到大排序，相同则按照右端点降序。</p></li>
<li><p>删除被包含的线段。通过对比右端点（因为左右端点已有序）。</p></li>
<li><p>WQS二分每次拍照额外的费用 <span class="math inline">\(C\)</span>
，值域设置到题目极限状态 <span class="math inline">\([0,m^2]\)</span>
，否则被卡。</p></li>
<li><p>设 <span class="math inline">\(f(i)\)</span> 为前 i
个线段所拍到的最少方格数量，则 <span class="math inline">\(F(i) = f(i) +
C * 拍照次数\)</span> 。</p></li>
<li><p>状态转移方程：</p>
<p><span class="math display">\[
F(i) = F(j)+(r_i-l_{j+1}-1)^2-G(j)+C,\quad G(j)=
\begin{align}\left\{\begin{aligned}&amp; (r_j-l_{j+1}+1)^2,\quad r_j \ge
l_{j+1} \\&amp; 0,\quad r_j &lt; l_{j+1}\end{aligned}\right.\end{align}
\]</span></p>
<p><span class="math inline">\(G(j)\)</span>
是新拍照区域和旧区域的重叠区域，根据是否重叠，减去重复计算的方格。</p></li>
<li><p>上面的式子平方项很眼熟，直接斜率优化+单调队列 <span class="math inline">\(O(n)\)</span> 解决。</p></li>
<li><p>最终时间复杂度为 <span class="math inline">\(O\left(n\log
(m^2)\right)= O(n\log m)\)</span> 。</p></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 100007</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">seg</span> &#123;ll l, r;&#125; a[MAXN];<br>ll n, m, k;<br>ll q[MAXN], head = <span class="hljs-number">0</span>, tail = <span class="hljs-number">-1</span>;<br>ll F[MAXN], CNT[MAXN], C;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQ(x) ((x)*(x))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> X(j) (a[j+1].l)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> G(j) (a[j].r&gt;=a[j+1].l?SQ(a[j].r-a[j+1].l+1):0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Y(j) (F[j]+SQ(a[j+1].l)-G(j)+C)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> K(i) (2*(a[i].r+1))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> B(i) (F[i]-SQ(a[i].r+1))</span><br><span class="hljs-comment">// 使用 &lt;= 尽可能多拍照片</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> slope_le_k(p1,p2,k) ((Y(p1)-Y(p2))&lt;=(X(p1)-X(p2))*(k))  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> k1_le_k2(p1,p2,p3,p4) ((Y(p1)-Y(p2))*(X(p3)-X(p4))&lt;=(Y(p3)-Y(p4))*(X(p1)-X(p2)))</span><br><span class="hljs-comment">// 斜率优化</span><br><span class="hljs-function">pair&lt;ll, ll&gt; <span class="hljs-title">check</span><span class="hljs-params">()</span> </span>&#123;<br>    head = <span class="hljs-number">1</span>, tail = <span class="hljs-number">1</span>;<br>    q[tail] = <span class="hljs-number">0</span>, F[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, CNT[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">while</span> (head &lt; tail &amp;&amp; <span class="hljs-built_in">slope_le_k</span>(q[head+<span class="hljs-number">1</span>], q[head], <span class="hljs-built_in">K</span>(i))) head++;<br>        ll j = q[head];<br>        F[i] = F[j] + <span class="hljs-built_in">SQ</span>(a[i].r-a[j+<span class="hljs-number">1</span>].l+<span class="hljs-number">1</span>) - <span class="hljs-built_in">G</span>(j) + C;<br>        CNT[i] = CNT[j] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (head &lt; tail &amp;&amp; <span class="hljs-built_in">k1_le_k2</span>(q[tail], i, q[tail<span class="hljs-number">-1</span>], q[tail])) tail--;<br>        q[++tail] = i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(F[n], CNT[n]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    a[<span class="hljs-number">0</span>].l = <span class="hljs-number">-1</span>, a[<span class="hljs-number">0</span>].r = <span class="hljs-number">-1</span>;   <span class="hljs-comment">// 非常重要，否则一开始G(0)会出错</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; a[i].l &gt;&gt; a[i].r;<br>        <span class="hljs-keyword">if</span> (a[i].l &gt; a[i].r) <span class="hljs-built_in">swap</span>(a[i].l, a[i].r);<br>    &#125;;<br>    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>, a+n+<span class="hljs-number">1</span>, [](seg _a, seg _b)&#123;<span class="hljs-keyword">return</span> _a.l==_b.l?_a.r&gt;_b.r:_a.l&lt;_b.l;&#125;);<br><br>    <span class="hljs-comment">// 去掉被包含的线段</span><br>    ll wp = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, prev_r = a[<span class="hljs-number">1</span>].r; i &lt;= n; i++)<br>        <span class="hljs-keyword">if</span> (prev_r &lt; a[i].r) a[++wp] = a[i], prev_r = a[i].r;<br>    n = wp;<br><br>    <span class="hljs-comment">// WQS二分</span><br>    ll lt = <span class="hljs-number">0</span>, rt = <span class="hljs-number">1e12</span>, val, cnt, ans = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (k &gt; n) k = n;  <span class="hljs-comment">// 用了这个优化，就不需要下面的 if (ans == -1) 了</span><br>    <span class="hljs-keyword">while</span> (lt &lt;= rt) &#123;<br>        C = (lt + rt) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">tie</span>(val, cnt) = <span class="hljs-built_in">check</span>();<br>        <span class="hljs-comment">// 在多点共线的线段上，[val, cnt] 是最后一个 &gt;= k 的值</span><br>        <span class="hljs-keyword">if</span> (cnt &gt;= k) lt = C + <span class="hljs-number">1</span>, ans = val - k * C;  <span class="hljs-comment">// [val, k] 和 [val, cnt] 共线</span><br>        <span class="hljs-keyword">else</span> rt = C - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (cnt == k) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 非常必要的小优化</span><br>    &#125;<br>    <span class="hljs-comment">// 虽然是凸函数，但是单调不增，并且最终无论拍多少次，都会收敛到一个值。</span><br>    <span class="hljs-comment">// 所以当 k &gt; n 时，cnt 必然小于 k，而 k 会和 n 共线</span><br>    <span class="hljs-comment">// if (ans == -1) ans = val - k * C;  </span><br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>同样对比两种不同的二分方式和F计算：</p>
<p><img title src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/aliens%E5%AF%B9%E6%AF%94-1712573757010-21.png" srcset="/img/loading.gif" lazyload alt="aliens对比" data-align="inline"></p>
<p>两种都可成功AC：</p>
<p><img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/image-20240203165559581-1712573757011-22.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="d0d-矩阵乘法优化">6 (2D/0D) 矩阵乘法优化</h2>
<p>https://www.cnblogs.com/Xing-Ling/p/11594147.html</p>
<h2 id="d1d-闵可夫斯基和优化">7 (1D/1D) 闵可夫斯基和优化</h2>
<p>参考博客：</p>
<p>https://www.cnblogs.com/SoyTony/p/Learning_Notes_about_DP_Optimization_3.html</p>
<p>https://www.luogu.com.cn/blog/juefan/Minkovski-Sum#</p>
<p>https://www.cnblogs.com/apjifengc/p/17041194.html</p>
<h3 id="概述">概述</h3>
<p>用于优化 <span class="math inline">\((\max/\min,+)\)</span>
卷积，形如：</p>
<p><span class="math display">\[
f_i=\max_{j=0}^i/\min_{j=0}^i \{g_j+h_{i-j}\}
\]</span></p>
<p>要求 <span class="math inline">\(g,h\)</span> 具有凸性。</p>
<p>计算 <span class="math inline">\(g\)</span> 和 <span class="math inline">\(h\)</span>
的差分序列，然后将两个序列进行归并排序，然后取前 <span class="math inline">\(i\)</span> 个元素。最终结果即为 <span class="math inline">\(f_i\)</span> 。</p>
<h3 id="算法流程">算法流程</h3>
<p>以 <span class="math inline">\(\max\)</span> 为例，要求 <span class="math inline">\(g,h\)</span> 形成上凸包，对 <span class="math inline">\(g,h\)</span> 差分，那么 <span class="math inline">\(f_i\)</span> 相当于在 <span class="math inline">\(\Delta g\)</span> 和 <span class="math inline">\(\Delta h\)</span> 中选两个前缀，要求长度和为 <span class="math inline">\(i\)</span>，权值和最大。由于 <span class="math inline">\(\Delta g\)</span> 和 <span class="math inline">\(\Delta h\)</span> 都单调不升，那么归并排序之后选前
<span class="math inline">\(i\)</span> 个数就是最优。</p>
<p>同理 <span class="math inline">\(\min\)</span> 要求 <span class="math inline">\(g,h\)</span> 形成下凸包。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">Minkowski</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; g,vector&lt;<span class="hljs-type">int</span>&gt; h)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; f;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=(<span class="hljs-type">int</span>)g.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">1</span>;--i) g[i]-=g[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=(<span class="hljs-type">int</span>)h.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">1</span>;--i) h[i]-=h[i<span class="hljs-number">-1</span>];<br>    f.<span class="hljs-built_in">resize</span>(g.<span class="hljs-built_in">size</span>()+h.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-built_in">merge</span>(g.<span class="hljs-built_in">begin</span>(),g.<span class="hljs-built_in">end</span>(),h.<span class="hljs-built_in">begin</span>(),h.<span class="hljs-built_in">end</span>(),f.<span class="hljs-built_in">begin</span>(),<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;f.<span class="hljs-built_in">size</span>();++i) f[i]+=f[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">return</span> f;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="优化-dp">优化 DP</h3>
<p>通常与分治同时使用。</p>
<p>转移方程形如：</p>
<p><span class="math display">\[
f_{i,j}=\max_{j=0}^i/\min_{j=0}^i\{f_{i-1,j}+w_{i,i-j}\}
\]</span></p>
<p>若 <span class="math inline">\(f,w\)</span>
均具有凸性，可以使用闵可夫斯基和优化至 <span class="math inline">\(O(n)\)</span> 转移一行，改成分治求区间的 <span class="math inline">\(f\)</span> 值，每一层的总规模 <span class="math inline">\(O(n)\)</span>，可以做到 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h3 id="例题">例题</h3>
<h4 id="qoj-5421-factories-once-more"><a target="_blank" rel="noopener" href="https://qoj.ac/contest/1093/problem/5421">QOJ-5421 Factories Once
More</a></h4>
<p>考虑树上背包，设 <span class="math inline">\(f_{u,i}\)</span> 为
<span class="math inline">\(u\)</span> 子树内选 <span class="math inline">\(i\)</span> 个节点的最大答案，转移是：</p>
<p><span class="math display">\[
f_{u,i}=\max_{j=0}^{siz_v}\{f_{u,i-j}+f_{v,j}+j(k-j)\times w(u,v)\}
\]</span></p>
<p>注意到贡献函数是上凸的，转移形如 <span class="math inline">\((\max,+)\)</span> 卷积，因此得知 <span class="math inline">\(f_u\)</span>
是上凸的，那么维护差分数组使用闵可夫斯基和优化。</p>
<p>需要启发式合并，维护单调不升的差分数组使用 Splay，而 <span class="math inline">\(j(k-j)\times w(u,v)\)</span>
差分后是等差数列，维护一个加等差数列的标记即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h3 id="参考资料">参考资料</h3>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/apjifengc/p/17041194.html">【学习笔记】闵可夫斯基和
- APJifengc</a></li>
</ul>
<h2 id="d1d-slope-trick">8 (1D/1D) Slope Trick</h2>
<p>这是一个优化凸函数合并的技巧。</p>
<p>这里使用的场景是：凸函数 <span class="math inline">\(f\)</span> +
凸函数 <span class="math inline">\(g\)</span> = 凸函数 <span class="math inline">\(h\)</span> （当然，他们的凸性必须相同）</p>
<h3 id="概述-1">概述</h3>
<p><img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/image-20240408194711081.png" srcset="/img/loading.gif" lazyload alt="两个下凸包" style="zoom: 50%;"></p>
<p>如图，是两个下凸包。通常，我们保存每一个点的坐标。</p>
<p>然而，这种方式在合并两个凸包时是比较麻烦的：我们必须对每个下标对应的元素进行加法操作。当然这在凸包比较多转折点时还是比较合理的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Convex hull 1</span><br>    <span class="hljs-type">int</span> ch1[<span class="hljs-number">7</span>] = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span> ,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-comment">// Convex hull 2</span><br>    <span class="hljs-type">int</span> ch2[<span class="hljs-number">7</span>] = &#123;<span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ,<span class="hljs-number">2</span>&#125;;<br><span class="hljs-comment">// All</span><br>    <span class="hljs-type">int</span> ch[<span class="hljs-number">7</span>] = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>&#125;;<br></code></pre></td></tr></table></figure>
<p>现在有一种新的方法来存储凸函数：保存斜率的变化点，在这个点处，斜率增加（或减少）了多少，就存几次这个点的下标。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Convex hull 1</span><br>    <span class="hljs-type">int</span> k1 = <span class="hljs-number">-3</span>, b1 = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span> ch1[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">// Convex hull 2</span><br>    <span class="hljs-type">int</span> k2 = <span class="hljs-number">-2</span>, b2 = <span class="hljs-number">6</span>;<br>    <span class="hljs-type">int</span> ch2[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-comment">// All</span><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">-5</span>, b = <span class="hljs-number">11</span>;<br>    <span class="hljs-type">int</span> ch[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br></code></pre></td></tr></table></figure>
<p><img src="/2024/01/20/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91DP%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/image-20240408200327345.png" srcset="/img/loading.gif" lazyload alt="合并后的凸包" style="zoom:50%;"></p>
<p>这种新方法需要将两个序列进行归并排序。</p>
<h3 id="例题-1">例题</h3>
<h4 id="cf713c-sonya-and-problem-wihtout-a-legend">1. <a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/713/C">CF713C Sonya and
Problem Wihtout a Legend</a></h4>
<p>题意：给定 <span class="math inline">\(n\)</span> 个正整数 <span class="math inline">\(a_i\)</span> ，每次操作可以选择任意一个数将其
<span class="math inline">\(+1\)</span> 或 <span class="math inline">\(-1\)</span> ，问至少需要多少次操作可以使得 <span class="math inline">\(n\)</span> 个数保持<strong>严格单增</strong>。</p>
<p>数据范围： <span class="math inline">\(1 \le n \le 3000,1\le a_i\le
10^9\)</span></p>
<p><strong>解题思路</strong></p>
<p>首先有一个技巧，可以<strong>将严格单增转化为单调不减</strong>。</p>
<p>假设 <span class="math inline">\(a_i\)</span> 为严格单增，则有 <span class="math inline">\(a_i + 1 \ge a_{i-1}\)</span> 。令 <span class="math inline">\(b_i = a_i - i\)</span> ，则有 <span class="math inline">\(b_i - b_{i-1} = a_i - i - [a_{i-1} -
(i-1)]=(a_i+1)-a_{i-1}\ge0\)</span> 。所以只需要维护 <span class="math inline">\(b_i\)</span> 为单调不减即可获得严格单增的 <span class="math inline">\(a_i\)</span>​ 。</p>
<p>设 <span class="math inline">\(f_{i,x}\)</span> 为前 <span class="math inline">\(i\)</span> 个数字，第 <span class="math inline">\(i\)</span> 个数 <span class="math inline">\(a_i\)</span> 最终变为 <span class="math inline">\(x\)</span> 所需的最少总操作数。则有：</p>
<p><span class="math display">\[
f_{i,x}=\min\{\min\limits_{t\le x}\{f_{i-1, t}\} + |a_i-x|\}
\]</span> <strong>朴素DP做法</strong></p>
<p>单调不增的序列有一个定理：</p>
<p>...</p>
<p>根据这个定理进行离散化，将 <span class="math inline">\(b\)</span>
进行排序后映射到下标。设排序后的 <span class="math inline">\(b\)</span>
数组为 <span class="math inline">\(bs\)</span> 。则：</p>
<p><span class="math display">\[
f_{i,j}=\min\{\min\limits_{t\le j}\{f_{i-1, t}\} +
\left|b[i]-bs[j]\right|\}
\]</span> 不过，这是从 <span class="math inline">\(b[i]\)</span> 变到
<span class="math inline">\(bs[j]\)</span>
的总最少耗费。可是为什么代码中却不用恢复减去的 <span class="math inline">\(i\)</span>​ 呢？</p>
<p>设 <span class="math inline">\(ac[i]\)</span> 为最终的严格单调序列，
<span class="math inline">\(bc[i]\)</span>
为最终的单调不减序列。则：</p>
<p><span class="math display">\[
\begin{align}
\min\limits_{j\le n}\{dp[n][j]\} &amp;= \sum|bc[i]-b[i]|\\
&amp;= \sum|(bc[i]+i)-(b[i]+i)|\\
&amp;= \sum |ac[i]-a[i]|
\end{align}
\]</span></p>
<p>所以这里不需要再对结果进行什么恢复操作了，直接遍历寻找
<code>dp[n][i]</code> 的最小值即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f3f3fLL</span><br>ll n, m, dp[<span class="hljs-number">3010</span>][<span class="hljs-number">3010</span>], b[<span class="hljs-number">3010</span>], bs[<span class="hljs-number">3010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;b[i]);<br>        b[i] -= i;<br>        bs[i] = b[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(bs + <span class="hljs-number">1</span>, bs + n + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (ll j = <span class="hljs-number">1</span>, fmin = INF; j &lt;= n; j++) &#123;<br>            fmin = <span class="hljs-built_in">min</span>(fmin, dp[i - <span class="hljs-number">1</span>][j]);<br>            dp[i][j] = fmin + <span class="hljs-built_in">abs</span>(b[i] - bs[j]);<br>        &#125;<br>    &#125;<br>    ll nmin = INF;<br>    <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        nmin = <span class="hljs-built_in">min</span>(nmin, dp[n][i]);<br>    cout &lt;&lt; nmin;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Slope Trick 做法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, t;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; Q;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;t);<br>    Q.<span class="hljs-built_in">push</span>(t);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t);<br>        t -= i;<br>        Q.<span class="hljs-built_in">push</span>(t);<br>        <span class="hljs-keyword">if</span> (Q.<span class="hljs-built_in">top</span>() &gt; t) &#123;<br>            ans += Q.<span class="hljs-built_in">top</span>() - t;<br>            Q.<span class="hljs-built_in">pop</span>();<br>            Q.<span class="hljs-built_in">push</span>(t);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="xdyd-数据结构优化">9 (xD/yD) 数据结构优化</h2>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95/" class="category-chain-item">算法</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="category-chain-item">动态规划</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/DP/">#DP</a>
      
        <a href="/tags/Algorithm-%E7%AE%97%E6%B3%95/">#Algorithm 算法</a>
      
        <a href="/tags/DP%E4%BC%98%E5%8C%96/">#DP优化</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【算法】DP优化总结</div>
      <div>https://qalxry.github.io/2024/01/20/【算法】DP优化总结/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>しずり雪</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年1月20日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2024年4月13日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                    <i class="iconfont icon-nc"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/01/27/%E3%80%90Hexo%E3%80%91%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E8%AE%B0%E5%BD%95-2024%E5%B9%B41%E6%9C%8826%E6%97%A5/" title="【Hexo】网站建设记录-2024年1月26日">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【Hexo】网站建设记录-2024年1月26日</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/01/17/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E3%80%90%E7%8A%B6%E5%8E%8BDP%E3%80%91%E6%9C%80%E7%9F%AD-Hamilton-%E8%B7%AF%E5%BE%84%E4%B8%AD%E8%A2%AB%E5%BF%BD%E8%A7%86%E7%9A%84%E7%8E%84%E5%A6%99%E4%B9%8B%E5%A4%84/" title="【算法】【状压DP】最短 Hamilton 路径中被忽视的玄妙之处">
                        <span class="hidden-mobile">【算法】【状压DP】最短 Hamilton 路径中被忽视的玄妙之处</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="right-sidebar side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
      <a href='https://hexo.io' target='_blank' rel='nofollow noopener'><span>Hexo</span></a> 
<i class='iconfont icon-love'></i>
<a href='https://github.com/fluid-dev/hexo-theme-fluid' target='_blank' rel='nofollow noopener'><span>Fluid</span></a>
<div style='font-size: 0.85rem'>
<span id='timeDate'>载入天数...</span>
<span id='times'>载入时分秒...</span>
<script src='/js/duration.js'></script>
</div>

    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              },
              lazyAlwaysTypeset: (function() {
                // 检查页面上是否存在 'mydetails' 元素
                if (!document.querySelector('mydetails')) {
                  return null; // 如果不存在，返回 null
                } else {
                  return ['mydetails']; // 如果存在，返回包含 'mydetails' 的数组
                }
                // 如果你直接给一个列表，那么如果页面上不存在这个元素，MathJax 将会崩溃
              })(),
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="/js/d3.v7.min.js"></script>
<script src="/js/custom/mydetails.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
